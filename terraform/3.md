---
up: "[[入門Terraform クラウド時代のインフラ統合管理]]"
related:
tags:
  - terraform
aliases:
  - terraform
created: 2026-01-12
updated: 2026-01-12
---
### 概要

#### 認証情報の保管

```bash
# Mac/Linux
export AWS_ACCESS_KEY_ID=""
export AWS_SECRET_ACCESS_KEY=""
export AWS_DEFAULT_REGION=""
```

#### 基本構成とコマンド

```terraform
terraform {
  required_providers {
    aws = {
      source = "hashicorp/aws"
			version = "~> 5.41.0"
    }
  }
}

provider "aws" {
	region = "ap-northeast-1"
}

resource "aws_instance" "test_server" {
	ami = "ami-0eba6c587918d3a1"
	instance_type = "t3.micro"

	tags = {
		Name = "TestInstance"
	}
}
```
「plan」実行の成功の場合「yes」を省略できるオプション
`terraform apply -auto-approve`

### 詳細

#### ==TerraformでWordpress環境を作成==

##### 必要になる環境
- WordPress本体
- Webサーバー
- データベースサーバー

##### VPCの作成
VPCは隔離された仮想ネットワーク環境です。
その上に、サブネットやルートテーブル、インターネットゲートウェイなどを作成する

CIDRブロック：`10.0.0.0/16`
タグ：`Main` コンソールから視認性を高める効果あり

```terraform
resource "aws_vpc" "main" {
	cidr_block = "10.0.0.0/16"  # VPCのIPアドレス範囲

	tags = {
		Name = "Main"  # VPCの名前
	}
}
```

##### サブネット
VPC（仮想プライベートクラウド）内のIPアドレス範囲を分割した「小さなネットワーク」のことです。
AWSの仕様上、サブネットはAZ単位で作成する

```terraform
# サブネット
resource "aws_subnet" "public" {
	vpc_id = aws_vpc.main.id  # 所属するVPCのID
	cidr_block = "10.0.1.0/24"  # サブネットのIPアドレス範囲
	tags = {
		Name = "Public"  # サブネットの名前
	}
}

resource "aws_subnet" "private_a" {
	vpc_id = aws_vpc.main.id  # 所属するVPCのID
	cidr_block = "10.0.2.0/24"  # サブネットのIPアドレス範囲
	availability_zone = "ap-northeast-1a"  # アベイラビリティーゾーン
	tags = {
		Name = "Private-A"  # サブネットの名前
	}
}

resource "aws_subnet" "private_c" {
	vpc_id = aws_vpc.main.id  # 所属するVPCのID
	cidr_block = "10.0.2.0/24"  # サブネットのIPアドレス範囲
	availability_zone = "ap-northeast-1c"  # アベイラビリティーゾーン
	tags = {
		Name = "Private-C"  # サブネットの名前
	}
}
```

##### インターネットゲートウェイ
VPCからインターネットに接続するための、ゲートウェイ

```terraform
resource "aws_internet_gateway" "gw" {
	vpc_id = aws_vpc.main.id  # アタッチするVPCのID
	tags = {
		Name = "Main"  # インターネットゲートウェイの名前
	}
}
```
##### ルートテーブル
作成したサブネット内で通信が行えるようにするのと、またインターネット向け通信はインターネットゲートウェイを経由して外に出て行くためにルートテーブルを作成

ルートテーブルはネットワークの「地図」のようなもので、どこにデータを送るかを決める大切な役割を果たします。

- CIDRはゲートウェイとして前項で作成したゲートウェイを設定
- ルートテーブルとVPCを紐付ける「aws_main_route_table_association」

```terraform
resource "aws_route_table" "main" {
	vpc_id = aws_vpc.main.id  # 所属するVPCのID

	route {
		cidr_block = "0.0.0.0/0"  # すべてのトラフィック
		gateway_id = aws_internet_gateway.gw.id  # インターネットゲートウェイへルーティング
	}

	tags = {
		Name = "Main"  # ルートテーブルの名前
	}
}

resource "aws_main_route_table_association" "main" {
	vpc_id = aws_route_table.id  # VPCのID
	route_table_id = aws_route_table.main.id  # メインルートテーブルとして設定するルートテーブルのID
}
```

##### セキュリティグループ
接続できるポートやIPを制御するためのもの

```terraform
resource "aws_security_group" "web" {
	name = "web"  # セキュリティグループ名
	description = "Allow Web Traffic"  # 説明
	vpc_id = aws_vpc.main.id  # 所属するVPCのID

	ingress {
		description = "HTTP from Internet"  # ルールの説明
		from_port = 80  # 開始ポート番号
		to_port = 80  # 終了ポート番号
		protocol = "tcp"  # プロトコル
		cidr_blocks = ["0.0.0.0/0"]  # 許可するIPアドレス範囲（全て）
	}

	ingress {
		description = "TLS from Internet"  # ルールの説明
		from_port = 443  # 開始ポート番号
		to_port = 443  # 終了ポート番号
		protocol = "tcp"  # プロトコル
		cidr_blocks = ["0.0.0.0/0"]  # 許可するIPアドレス範囲（全て）
	}

	egress {
		from_port = 0  # 開始ポート番号（全て）
		to_port = 0  # 終了ポート番号（全て）
		protocol = "-1"  # プロトコル（全て）
		cidr_blocks = ["0.0.0.0/0"]  # 許可するIPアドレス範囲（全て）
	}

	tags = {
		Name = "web"  # セキュリティグループの名前
	}
}

resource "aws_security_group" "db" {
	vpc_id = aws_vpc.main.id  # 所属するVPCのID
	ingress {
		from_port = 3306  # MySQLのポート番号（開始）
		to_port = 3306  # MySQLのポート番号（終了）
		protocol = "tcp"  # プロトコル
		cidr_blocks = [  # 許可するIPアドレス範囲
			aws_subnet.public.cidr_block,  # パブリックサブネット
			aws_subnet.private_a.cidr_block,  # プライベートサブネットA
			aws_subnet.private_c.cidr_block  # プライベートサブネットC
		]
	}

	egress {
		from_port = 0  # 開始ポート番号（全て）
		to_port = 0  # 終了ポート番号（全て）
		protocol = "-1"  # プロトコル（全て）
		cidr_blocks = ["0.0.0.0/0"]  # 許可するIPアドレス範囲（全て）
	}

	tags = {
		Name = "sg_rds"  # セキュリティグループの名前
	}
}
```

##### RDS
データベースサーバーをAmazon RDSを使用して作成
Randomプロパイダーを作成してパスワードに使用

```terraform
resource "aws_db_instance" "wordpress" {
  allocated_storage    = 20  # 初期ストレージサイズ（GB）
  storage_type         = "gp2"  # ストレージタイプ（汎用SSD）
  engine               = "mysql"  # データベースエンジン
  engine_version       = "8.0"  # MySQLのバージョン
  instance_class       = "db.t3.micro"  # インスタンスタイプ
  db_name              = "wordpress"  # 作成するデータベース名
  username             = "admin"  # マスターユーザー名
  password             = random_password.wordpress.result  # マスターパスワード（ランダム生成）
	parameter_group_name = "default.mysql8.0"  # パラメータグループ
	multi_az = false  # マルチAZ配置（無効）
	db_subnet_group_name = aws_db_subnet_group.db.name  # DBサブネットグループ名
	vpc_security_group_ids = [aws_security_group.db.id]  # セキュリティグループID
	backup_window = "01:00-02:00"  # バックアップウィンドウ（UTC）
  skip_final_snapshot  = true  # 削除時の最終スナップショットをスキップ（開発環境用）
	max_allocated_storage = 200  # ストレージ自動スケーリングの最大サイズ（GB）
	identifier = "wordpress"  # DBインスタンス識別子

	tags = {
		Name = "WordPress DB"  # DBインスタンスの名前
	}
}

resource "aws_db_subnet_group" "db" {
	name = "wordpress"  # DBサブネットグループ名
	subnet_ids = [aws_subnet.private.id]  # DBが使用するサブネットIDのリスト
	tags = {
		Name = "DB subnet group"  # DBサブネットグループの名前
	}
}

resource "random_password" "wordpress" {
	length = 16  # パスワードの文字数
	special = true  # 特殊文字を含める
	override_special = "12345678!?"  # 使用する特殊文字を指定
}
```

##### EC2インスタンス
「aws_network_interface」というリソースは、AWSのネットワークインターフェイスを作成するものです。
EC2インスタンスにネットワークインターフェイスをアタッチすることで、指定したサブネットに接続できます
ネットワークインターフェイスには接続先のサブネットとセキュリティグループを指定します。
また「aws_eip」はパブリックIPを利用するのに必要なElastic IPを作成するリソースです

```terraform
resource "aws_instance" "web" {
	ami = "ami-0eba6c58b7918d3a1"  # Amazon Machine Image ID（Amazon Linux 2023）
	instance_type = "t2.micro"  # インスタンスタイプ
	network_interface {
		network_interface_id = aws_network_interface.web.id  # アタッチするネットワークインターフェースID
		device_index = 0  # デバイスインデックス（プライマリ）
	}
	user_data = file("wordpress.sh")  # 起動時に実行するスクリプト
	tags = {
		Name = "web"  # EC2インスタンスの名前
	}
}

resource "aws_network_interface" "web" {
	subnet_id = aws_subnet.public.id  # ネットワークインターフェースを配置するサブネットID
	private_ips = ["10.0.1.50"]  # プライベートIPアドレス
	security_groups = [aws_security_group.web.id]  # アタッチするセキュリティグループID
}

resource "aws_eip" "wordpress" {
	network_interface = aws_network_interface.web.id  # Elastic IPを関連付けるネットワークインターフェースID
	domain = "vpc"  # VPC用のElastic IP
}
```

##### outputsファイルを作成
「output」ブロックを利用すると、CLIの実行後や「terraform output」コマンドで、指定した値を表示可能になる

```terraform
output "public_ip" {
  value = aws_eip.wordpress.public_ip
}

output "rds_endpoint" {
	value = aws_db_instance.wordpress.endpoint
}

output "rds_password" {
	value = random_password.wordpress.result
	sensitive = true
}

```

#### ==複数のリソースを作成する==
手続き型以外にも複数のリソースを効率的に作成できる方法

#### ループの利用
Meta-Argumentと呼ばれる、リソース内で利用できる特殊な記述です
mapやsetをfor_eachに渡すことで、その中身をループ可能

```terraform
# フロントエンドサーバー用のネットワークインターフェース
resource "aws_network_interface" "frontends" {
	for_each = toset(local.frontends)  # リストをセットに変換してループ
	subnet_id = aws_subnet.public.id  # パブリックサブネットに配置
	security_groups = [aws_security_group.web.id]  # Webセキュリティグループを適用
}

# フロントエンドサーバー用のEC2インスタンス
resource "aws_instance" "frontends" {
	for_each = toset(local.frontends)  # リストをセットに変換してループ
	ami = "ami-0eba6c58b7918d3a1"  # Amazon Machine Image ID（Amazon Linux 2023）
	instance_type = "t2.micro"  # インスタンスタイプ

	network_interface {
		network_interface_id = aws_network_interface.frontends[each.value].id  # 対応するネットワークインターフェースを指定
		device_index = 0  # デバイスインデックス（プライマリ）
	}

	tags = {
		Name = "Frontend-${each.value}"  # 各インスタンスに一意の名前を付与（例: Frontend-web1）
	}
}
```

##### localsとは？
**locals = ローカル変数を定義するブロック**
Terraformコード内で**計算や組み合わせた値を一度定義して、何度も再利用する**ための機能です。

```hcl
locals {
  変数名1 = 値1
  変数名2 = 値2
  変数名3 = 計算式
}

# 使う時は local.変数名
resource "aws_instance" "web" {
  tags = {
    Name = local.変数名1
  }
}
```

##### countの利用（非推奨）
countというメタ引数を使って複数リソースを作る方法もあります。
`aws_instance.servers[1]`のようにアクセスできて便利に見えるが、配列の連番になっている
その為、途中のソースを削除した場合、Terraformの配列の詰め直しが必要なので、for_eachを使う必要がある

```terraform
resource "aws_instance" "servers" {
	count = 3
	ami = "ami-0eba6c58b7918d3a1"
	instance_type = "t2.micro"

	tags = {
		Name = "Server ${count.index}"
	}
}
```
##### countの使い道
「count = 0」という使い方がある。
リソースを作成しないの意味
頻繁によく使うテクニック

```terraform
variable "create_instance" {
	type = bool
	default = false
}

resource "aws_instance" "server" {
	count = var.create_instance ? 1 : 0
	ami = "ami-0eba6c58b7918d3a1"
	instance_type = "t2.micro"

	tags = {
		Name = "Server"
	}
}
```

#### AWSプロパイダーに権限を渡す方法
- 環境変数
- provider ブロック内のコンフィグ
- AWS CLI設定ファイル
- IAMインスタンスプロファイル
- HCP TerraformのDynamic Provider Credentials

##### 環境変数

```bash
export AWS_ACCESS_KEY_ID=""
export AWS_SECRET_ACCESS_KEY=""
export AWS_DEFAULT_REGION=""
```

##### provider ブロック内のコンフィグ（非推奨）
Gitに上がる可能性があるので
```hcl
provider "aws" {
	region = "リージョン"
	access_key = "アクセスキー"
	secret_key = "シークレットアクセスキー"
}
```

##### AWS CLI設定ファイル
AWS CLIを利用する
`aws configure` コマンドを使用してログインを行うと
`$HOME/.aws/config` および `$HOME/.aws/credentials` に書き込まれる
以下でプロファイルを分けることが可能
```bash
aws config --profile staging
export AWS_PROFILE=staging
```

```hcl
# Terraform側（何も書かない！）
provider "aws" {
  region = "ap-northeast-1"
  # 認証情報は自動的に読み込まれる
}

# プロファイル指定する場合
provider "aws" {
  region  = "ap-northeast-1"
  profile = "dev"
}

#指定も可能
provider "aws" {
  shared_config_files = ["/Users/your_user/.aws/conf"]
  shared_credentials_files = ["/Users/your_user/.aws/creds"]
  profile = "staging"
}
```

##### IAM インスタンスプロファイル
terraformコマンドをAWS EC2上のVMで実行する場合、そのVMにIAMインスタンスプロファイルが設定されていれば、その権限を使って実行できます。


##### HCP TerraformのDynamic Provider Credentials
より安全にTerraformを使ったAWSの構築を行いたい場合、クラウドサービスHCP Terraformを利用するのもお勧めです。
提供されている 「Dynamic Provider Credentials」を利用することで、環境変数なくても安全に権限を渡すことが可能

#### AWSCC プロバイダーのドキュメントURL
本書では解説しませんが、AWSCCプロパイダーというものも提供されている
AWSが提供している新たなAPIであるAWS Cloud Control APIを利用するプロパイダーです。
こちらはAWSが公式に提供しているAWSCloudFormationレジストリと連動している

#### HashiCorp Developer
AWSへのチュートリアルが豊富に提供されている。
