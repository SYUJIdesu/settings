---
up: "[[Clean Architecture 達人に学ぶソフトウェアの構造と設計]]"
related:
tags:
  - アーキテクチャ
  - クリーンアーキテクチャ
aliases:
  - クリーンアーキテクチャ
created: 2025-12-17
updated: 2025-12-17
---
### 概要

#### ==アーキテクチャの目的==
アーキテクチャは、細部の多少の違いがあるものの、非常によく似ている
いずれも「関心事の分離」という目的を持っている

そしてソフトウェアをレイヤーに分離することで、この分離を実現している
またそれぞれ少なくとも、ビジネスルールのレイヤーとユーザーやシステムとのインターフェイスレイヤーを持っている

#### ==アーキテクチャの特性==
アーキテクチャは、以下の特性を持つシステムを生み出します
- **フレームワーク非依存**
	- 機能満載のライブラリに依存していない。これにより、システムをフレームワークの制約で縛るのではなく、フレームワークをツールとして使用できる
- **テスト可能**
	- ビジネスルールとは、UI、データベース、ウェブサーバー、その他の外部要素がなくてもテストできる
- **UI非依存**
	- UIは、システムの他の部分を変更する事なく、簡単に変更ができる。
	- 例えば、ビジネスルールを変更する事なく、ウェブUIをコンソールUIに置き換えることができる。
- **データベース非依存**
	- RDSやNOSQL問わずに置き換えることが可能。ビジネスルールはデータベースに束縛されていない
- **外部エージェント非依存**
	- ビジネスルールは、外界のインターフェイスについて何も知らない



### 詳細

##### ==クリーンアーキテクチャ==

![[clean.png]]



#### ==依存性のルール==
ソースコードの依存性は、内側に（上位レベルの方針）だけに向かっていなければならない。
- 円の内側は外について何も知らない。
- 外側のものを内側が使用してはならない

#### ==エンティティ==
企業全体の最重要ビジネスルールをカプセル化したもの
外側で何か変化が起きても、それが変化する可能性が低い

##### 主に4種類のクラスを作成

###### メインエンティティ (Domain Entities)
ビジネスの主役となる「名詞」です。**ID（識別子）** を持ち、そのライフサイクルを通じて同一性が保たれるオブジェクトです。
- **特徴**: データだけでなく、データを操作する「メソッド（振る舞い）」を持ちます。
- **例**: `User`（ユーザー）, `Order`（注文）, `Product`（商品）

###### 値オブジェクト (Value Objects)
単なるプリミティブ型（string, int）の代わりに、**「概念」** を包み込んだクラスです。IDを持たず、値そのものが重要です。
- **特徴**: 不変（Immutable）であること。値が変わる時は別のオブジェクトを作ります
- **例**: `EmailAddress`（メールアドレス）, `Money`（金額）, `Address`（住所）
- **メリット**: 「不正な値（例: @がないメアド）」が存在することを防げます。

###### ドメインサービス (Domain Services)
一つのエンティティに収まらない、**複数のエンティティにまたがる操作**やルールを記述するクラスです。
- **特徴**: 「状態」を持たず、「操作（動詞）」だけを持ちます。
- **例**: `MoneyTransferService`（送金処理）, `OrderPriceCalculator`（複雑な割引計算）
- **注意**: 何でもかんでもサービスにすると、エンティティがスカスカになる（ドメインモデル貧血症）ので注意が必要です。

###### ファクトリ (Factories)
複雑なエンティティや集約（Aggregates）を**生成するため**のクラス/メソッドです。
- **特徴**: 生成ロジックが複雑な場合、エンティティのコンストラクタに書くと汚くなるため、生成専門のクラスに切り出します。
- **例**: `OrderFactory`（初期状態の注文を作成する）


#### ==ユースケース==
**アプリケーション固有**のビジネスルールが含まれている
ここにはシステムの全てのユースケースがカプセル化・実装されている。
ユースケースは、エンティティに入出力するデータの流れを調整し、ユースケースの目標を達成できるように、エンティティに最重要ビジネスルールを使用するように指示を出す

ユースケースの変更はエンティティに影響しない
データベース・UI・フレームワークなどの外部の変更の影響を受けることもない。
<mark style="background: #D2B3FFA6;">アプリケーション操作の変更がユースケースに影響を与え、ソフトウェアにまで影響することもある</mark>

##### 主に5種類のクラスを作成

###### Interactor（インタラクタ）
**主役**です。具体的なビジネスロジック（手順）の実装クラスです。 「ユーザー登録する」「商品を注文する」といった**1つのユースケースにつき1つのクラス**を作ります。
- **役割**: 入力を受け取り、Entityを動かし、DBに保存し、結果を出力へ渡す。
- **命名例**: `CreateUserInteractor`, `PlaceOrderInteractor`
    

###### Input Data (Input DTO)
**入力データ**の入れ物です。Web（Controller）からユースケースへ渡される引数です。 単純なクラスや構造体で、ロジックは持ちません。
- **役割**: ControllerがHTTPリクエストから取り出したデータをここに詰めて渡す。
- **命名例**: `CreateUserInputData`, `RegisterUserRequest`

###### Output Data (Output DTO)
**出力データ**の入れ物です。ユースケースからWeb（Presenter）へ返す戻り値です。 ここにはEntityそのものを入れず、必要なデータだけを詰め替えます（Entityを外に漏らさないため）。
- **役割**: 処理結果（成功/失敗、作成されたIDなど）を運ぶ。
- **命名例**: `CreateUserOutputData`, `RegisterUserResponse`

###### Output Boundary（出力の境界）
**インターフェース**です。Interactorが結果を通知するための相手（Presenter）の形を定義します。 DIP（依存関係逆転）のために必要です。

厳密なClean Architectureの図には **Input Boundary（入力の境界）** というインターフェースもあり、Controllerはそれを経由してInteractorを呼び出します。

しかし、実際のPHP開発（特にLaravelなど）では、Controllerが直接 Interactor クラスを呼んでも実害が少ないため、**Input Boundary（インターフェース）は省略されることが多い**です。
- **役割**: 「私は結果をこういう形で渡しますよ」という契約。
- **命名例**: `CreateUserPresenterInterface`

###### Repository Interface（リポジトリのインターフェース）
**インターフェース**です。DB操作の定義です。 実装クラス（SQLを書くクラス）は外側の層に置きますが、**「どんな操作が必要か」という定義はこの層の持ち物**です。
- **役割**: 「IDでユーザーを検索したい」「保存したい」という要求を定義する。
- **命名例**: `UserRepositoryInterface`


#### ==インターフェイスアダプター==
ユースケースやエンティティに便利なフォーマットから、データベースやウェブなどの外部エージェントに便利なフォーマットにデータを変換するアダプターである。

##### 主に3種類のクラスを作成

###### Controller（コントローラー）
**【役割：Web $\to$ ユースケースへの変換】**
Webからの入力（HTTPリクエストなど）を受け取り、ユースケース層が理解できる `Input Data` に変換して、Interactorを実行するクラスです。
- **やること**:
    1. ユーザーの入力（`$_POST` や JSON）を受け取る。
    2. それを `CreateUserInputData`（ユースケース層のクラス）に詰め替える。
    3. `Interactor` を呼び出す。
- **注意**: ここにビジネスロジックは書きません。あくまで「交通整理」と「荷造り」だけです。

###### Presenter（プレゼンター）
**【役割：ユースケース $\to$ Web(View)への変換】**
ユースケースから出力された `Output Data` を受け取り、画面（HTMLやJSON）に表示しやすい形（ViewModel）に整形するクラスです。
- **重要**: ユースケース層にある `Output Boundary` インターフェースを実装（implements）します。
- **やること**:
    1. `Output Data`（生データ）を受け取る。
    2. 日付を「Y年m月d日」にフォーマットしたり、booleanを「あり/なし」の文字列に変えたりする。
    3. Viewに渡すためのデータ（ViewModel）を作る。


###### Gateway / Repository Implementation（リポジトリの実装）
**【役割：ユースケース $\leftrightarrow$ DBへの変換】**
ユースケース層にある `Repository Interface` を実装（implements）し、実際にSQLやORMを使ってデータベースを操作するクラスです。
- **重要**: ここがDIP（依存関係逆転）のキモです。
    - **インターフェース（ルール）** はユースケース層にある。
    - **実装（SQL操作）** はアダプター層にある。
- **やること**:
    1. DBからレコードを取得する。
    2. レコード（配列やORMオブジェクト）を **Entity** に変換して返す。
    3. または、**Entity** を受け取ってDBに保存する。


#### ==円の一番外側==
フレームワークやツールで構成されている。
このレイヤーには詳細が詰まっているので、被害が少ないようにこれらは外側に置く


#### ==4つの円だけ==
円は4つでなくてもいい。
但し、依存性のルールは常に内側に向ける

#### ==境界線を越える==
クリーンアーキテクチャにおいて「**円の内側から外側へアクセスする（データを渡す、保存する、表示する）**」ための唯一の手段が「**依存関係逆転の原則（DIP）**」です。
なぜそうなるのか、「**処理の流れ**」と「**ルールの矛盾**」を使って解説します。

#### ==境界線を越えるデータ==
境界線を超えて渡すのは、独立したデータ構造であることが重要

エンティティそのものや、データベースの行（Row）、フレームワークのRequestオブジェクトなどをそのまま渡してはいけません。

要点は、**「境界を越えるための専用の『ただのデータの箱』を用意して、それに詰め替えて渡す」** ということです。

###### 1. 守るべき鉄の掟
> **「データを渡す形式（クラス）は、常に『内側の層』が定義する」**

外側から内側へ入るときも、内側から外側へ出るときも、**「内側の層が用意した箱」**を使います。
- **入力時**: Controller（外）は、UseCase（内）が用意した `Input Data` にデータを詰めて渡す。
- **出力時**: UseCase（内）は、自分が定義した `Output Data` にデータを入れて Presenter（外）に渡す。
###### 2. なぜ詰め替えるのか？（DTOを使う理由）
「面倒くさいから、EntityをそのままControllerやViewに渡せばいいじゃん」と思うかもしれません。しかし、それは**危険**です。
- **理由1: 依存の分離** もしEntityをそのままView（HTML）で使ってしまうと、**「画面のデザインを変えたいだけなのに、ビジネスロジック（Entity）を修正しないといけない」** という逆転現象が起きたり、その逆（Entityを変えたら画面が壊れる）が起きたりします。
- **理由2: セキュリティ** Entityには `password_hash` や `salary`（給与）などの機密情報が含まれているかもしれません。DTOに詰め替えることで、**画面に出してはいけないデータを物理的に除外**できます。


##### ==ユーザーの視点==

ユーザーの視点からすると、オブジェクトは操作の集合である。

データは関係ない内部を見れないからシステムのアーキテクチャは、上位レベルの方針と下位レベルの詳細を分離し、依存性のルールに従う境界によって定義される横断的関心事の問題であるアーキテクチャの境界はサービスとサービスの間ではなく、サービスを横断してコンポーネントごとに分割している  

ソフトウェアは消耗しないが、ファームウエアやハードウェアは時代遅れになる。その結果ソフトウェアの変更が必要になるアーキテクトの第一歩はアクターとユースケースを見つけることだ