---
up:
related:
tags:
  - アーキテクチャ
aliases:
  - クリーンアーキテクチャ
created: 2025-12-16
updated: 2025-12-16
---
### 概要
```cardlink
url: https://amzn.asia/d/eSIcwhB
title: "Clean Architecture 達人に学ぶソフトウェアの構造と設計 | Robert C.Martin, 角 征典, 高木 正弘 |本 | 通販 | Amazon"
description: "AmazonでRobert C.Martin, 角 征典, 高木 正弘のClean Architecture 達人に学ぶソフトウェアの構造と設計。アマゾンならポイント還元本が多数。Robert C.Martin, 角 征典, 高木 正弘作品ほか、お急ぎ便対象商品は当日お届けも可能。またClean Architecture 達人に学ぶソフトウェアの構造と設計もアマゾン配送商品なら通常配送無料。"
host: amzn.asia
```


### 詳細

#### 1. アプリケーションの核心原則

##### 目的
ソフトウェアの目的は「機能すること」だけではない。
**「最小の人的リソース（コスト）で、システムの構築・保守・拡張をし続けること」** がアーキテクチャの真の目的である。

###### ソフトウェアの2つの価値
1.  **振る舞い (Behavior)**: 機能要件（何をするか）。緊急度は高いが、重要度は低いことが多い。
2.  **構造 (Structure)**: 非機能要件（変更しやすさ）。緊急ではないが、常に重要である。
    * アーキテクチャは「構造」に責任を持つ。

###### 方針と詳細の分離
* **方針 (Policy)**: ビジネスのルール。システムの本質。重要。
* **詳細 (Detail)**: Web、データベース、UI、フレームワーク。交換可能で重要度が低い。
* **結論**: **「詳細」が「方針」に依存すべきであり、その逆であってはならない。**

---

#### 2. 依存性のルール (The Dependency Rule)

> **「ソースコードの依存関係は、常に内側（高レベルな方針）に向かっていなければならない」**

円の中心に行くほど、抽象度が高く、変更されにくい（安定した）コンポーネントになる。

##### 4つの層（The Concentric Circles）

| 層（色） | 名称 | 役割 | 含まれるもの | 依存の方向 |
| :--- | :--- | :--- | :--- | :--- |
| **1. 黄** | **エンティティ**<br>(Entities) | **企業最重要ビジネスルール**<br>アプリに依存しない普遍的なドメインロジック。 | Entity, Value Object | 依存しない |
| **2. 赤** | **ユースケース**<br>(Use Cases) | **アプリケーションビジネスルール**<br>システム固有の機能・シナリオ。 | Interactor,<br>Repository Interface | $\to$ Entities |
| **3. 緑** | **I/Fアダプター**<br>(Interface Adapters) | **変換層**<br>内側と外側のデータ形式を変換する。 | Controller, Presenter,<br>Repository Impl | $\to$ Use Cases |
| **4. 青** | **FWとドライバ**<br>(Frameworks) | **詳細**<br>外部との接点。最も変更されやすい。 | Web, DB, UI, Devices | $\to$ I/F Adapters |

---

#### 3. SOLID原則（クラス設計の原則）

| 原則 | 名前 | 概要 |
| :--- | :--- | :--- |
| **SRP** | 単一責任の原則 | クラスを変更する理由はひとつだけでなければならない。 |
| **OCP** | オープン・クローズドの原則 | 拡張には開き、修正には閉じる（既存コードを変えずに機能追加せよ）。 |
| **LSP** | リスコフの置換原則 | 派生型は基本型と置換可能でなければならない。 |
| **ISP** | I/F分離の原則 | 使わないメソッドへの依存を強制してはならない。 |
| **DIP** | 依存関係逆転の原則 | 具体ではなく抽象に依存せよ。（外側へのアクセスに必須） |

---

#### 4. コンポーネントの設計原則

コンポーネントとは「デプロイの単位（jar, dll, package）」である。

##### 凝集度（何を入れるか）
* **REP (再利用・リリース等価の原則)**: 再利用の単位とリリースの単位は同じにする。
* **CCP (閉鎖性共通の原則)**: 同じ理由、同じタイミングで変更されるクラスをまとめる（SRPのコンポーネント版）。
* **CRP (全再利用の原則)**: 一緒に使われないクラスを同じコンポーネントに入れない（ISPのコンポーネント版）。

##### 結合度（どう繋ぐか）
* **ADP (非循環依存の原則)**: 依存グラフに循環（サイクル）を作ってはならない。
* **SDP (安定依存の原則)**: **安定度の高い（変更しにくい）方向へ依存せよ**。
    * 安定度 $I = Ce / (Ca + Ce)$
    * $I=0$ (安定) $\leftarrow$ $I=1$ (不安定)
* **SAP (安定・抽象化等価の原則)**: 安定したコンポーネントは抽象的（インターフェース中心）であるべきだ。

---

#### 5. 実装テクニック

##### 境界を越えるデータ (Crossing Boundaries)
* 層をまたぐ時は、Entityをそのまま渡さず、単純なデータ構造（**DTO**: Input/Output Data）に詰め替える。
* データの定義（DTOクラス）は、常に**内側の層**が所有する。

##### 依存関係逆転 (DIP) の適用
内側（UseCase）から外側（DB/Web）を操作したい場合：
1.  **内側**にインターフェース（`RepositoryInterface`, `OutputBoundary`）を定義する。
2.  **外側**でそれを実装（`RepositoryImpl`, `Presenter`）する。
3.  これにより、ソースコードの依存は**内側**に向くが、処理の流れは**外側**へ向く。

##### Humble Object パターン
テストしにくいコード（View, DB）と、テストしやすいロジック（Presenter, Interactor）を分離する。
* **Humble Object**: ロジックを持たず、言われた通りにするだけ（テスト不要）。
* **Logic**: テストカバレッジを高く保つ。

---

#### 6. 結論
* **「Webは詳細である」**: Webは単なる入出力装置。ビジネスロジックを依存させてはならない。
* **「データベースは詳細である」**: DBはデータを永続化する仕組みに過ぎない。
* 良いアーキテクチャは、詳細（フレームワークやDB）の決定を**可能な限り先延ばし**にできる。



### 関連ページ
```dataview
LIST
WHERE up = [[Clean Architecture 達人に学ぶソフトウェアの構造と設計]]
SORT file.name ASC
```