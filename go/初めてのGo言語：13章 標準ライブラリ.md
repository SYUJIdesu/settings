---
up: "[[初めてのGo言語]]"
related:
tags:
  - golang
aliases:
  - golang
created: 2026-01-02
updated: 2026-01-02
---
### 概要

Goは標準ライブラリが充実していて、アプリケーション構築に必要なものは「すぐに使えるように全て含める」
Goは比較的新しい言語で、近年のプログラミング言語で遭遇する問題の解決に向けて、様々なライブラリが用意されている。

この章では、入出力、時間・時刻、JSON、HTTPについて取り上げる
他にerrors,sync,context,testing,reflect,unsafeがある

### 詳細

#### ==入出力==
パッケージioを使用

###### パッケージio
Goの **パッケージ `io`** は、データの入出力（Input/Output）に関する最も基本的かつ汎用的な「道具箱」です。

実務において「ファイルを読む」「ネットワークでデータを送る」「メモリ上のデータを加工する」といった処理はすべて、この `io` パッケージが提供する**インターフェース**を土台に設計されています。

インターフェース「io.Reader」と「io.Writer」が定義されているが、メソッドは各一つ

```go

type Reader interface {
	Read(p []byte) (n int, err error)
}

type Write interface {
	Write(p []byte) (n int, err error)
}
```


###### `id.Redaer` の実装でよく使用されるもの

|**実装（構造体）**|**用途**|
|---|---|
|**`os.File`**|ローカルファイルからの読み込み。|
|**`net.Conn`**|ネットワークソケットからの読み込み。|
|**`http.Response.Body`**|HTTPレスポンスの受信データ。|
|**`bytes.Buffer`**|メモリ上のバイト配列の読み書き。|
|**`strings.Reader`**|文字列を `Reader` として扱う（テストで便利）。|

#### ==timte==
二つの型が用意されている
- `time.Duration` 
- `time.Time`

| **型**               | **意味**     | **例え**        | **具体的な例**       |
| ------------------- | ---------- | ------------- | --------------- |
| **`time.Time`**     | **時刻（点）**  | カレンダーの特定の日付   | 2026年1月2日 20:54 |
| **`time.Duration`** | **時間（長さ）** | ストップウォッチの計測時間 | 5秒間、2時間、15分     |

##### time.duration（期間・時間量）
「どのくらいの長さか？」を表すデータ型です。
- **中身**: 内部的にはナノ秒（int64）の数値です。
- **単位の書き方**: `time.Second`（1秒）や `time.Hour`（1時間）などの定数を掛けて表現します。
- **主な用途**:
    - 処理を待機させる（`time.Sleep(5 * time.Second)`）
    - タイムアウトの設定
    - 2つの時刻の差分
```go
d := 2*time.Hour + 30*time.Minute + 15*time.Second //dの型はtime.Duration
fmt.Println(d) //2h30m15s
```

##### time.Time（時刻）
型time.Timeが表されて、タイムゾーンが付随する
- format：Time型から文字列に変換
- Parse：文字列からTimeに変換
- 
APIのレスポンスやログ出力では、独自のフォーマットではなく、標準規格である **RFC3339 (ISO8601)** を使うのがプロの鉄則です。Goにはそのための定数が用意されています。

```go
now := time.Now()

//
fmt.Println(now.Format(time.RFC3339)) //2026-01-02T21:02:07+09:00
fmt.Println(now.Format(time.ANSIC)) //Fri Jan 2 21:02:07 2026
```

##### モノトニックタイム
Go言語（Go 1.9以降）は「両方を賢く使い分けて」います。

ひとつの `time.Time` 構造体の中に、ウォールクロック（壁時計）とモノトニッククロック（単調増加時計）の両方の情報を同時に保持する設計になっています。

| **クロックの種類**    | **役割**                  | **弱点**                                           | 使用用途            |
| -------------- | ----------------------- | ------------------------------------------------ | --------------- |
| **ウォールクロック**   | 「今、何時何分？」を教える（時刻の表示用）   | システム時刻の補正（NTP同期）や「うるう秒」で**時間が戻ったり飛んだりする**。       | ログ出力やデータベースへの保存 |
| **モノトニッククロック** | 「あれから何秒経った？」を測る（時間の計測用） | パソコンを起動してからの経過時間などに依存するため、「2026年」といった日付の情報は持たない。 | 時間の比較や計算        |
##### タイマーとタイムアウト
`time` パッケージとチャネル（Channel）は切っても切れない関係にあります。
`time` パッケージの多くの機能は、「時間が経過したことをチャネル経由で通知する」という仕組みで動いているからです。

| **道具**            | **戻り値**              | **主な用途**             | **停止** |
| ----------------- | -------------------- | -------------------- | ------ |
| **`time.After`**  | `<-chan Time`        | `select` での簡単なタイムアウト | 不可     |
| **`time.Timer`**  | `*Timer` (内部にCチャネル)  | 停止やリセットが必要な待機        | **可能** |
| **`time.Ticker`** | `*Ticker` (内部にCチャネル) | 定期的なバッチ処理、監視         | **可能** |
| **`time.Tick`**   | `<-chan Time`        | 非常に単純な繰り返しのデモ用       | 不可     |

```go
package main

import (
	"fmt"
	"time"
)

func main() {
	// 日本時刻の設定（表示用）
	jst := time.FixedZone("JST", 9*60*60)
	fmt.Printf("--- 実装開始時刻: %s ---\n", time.Now().In(jst).Format("15:04:05"))

	// 1. time.Ticker: 定期的な繰り返し処理
	// 1秒ごとに信号を送る「メトロノーム」のような存在。
	// Stop() メソッドで明示的に止めることができるため、実務で最も使われます。
	heartbeat := time.NewTicker(1 * time.Second)
	defer heartbeat.Stop() // 処理が終わったらリソースを解放する

	// 2. time.Timer: 指定時間後に1回だけ実行（制御可能）
	// time.After と似ているが、「途中で止める（Stop）」や「時間の再設定（Reset）」ができる。
	// 「特定の条件になったら実行をキャンセルしたい」場合に便利。
	delayedJob := time.NewTimer(5 * time.Second)

	// 3. time.Tick: 簡易的な繰り返し（停止不可）
	// time.NewTicker の簡易版。チャネルだけを返すが、止める手段がない。
	// プログラムの寿命と同じ期間動き続ける「監視用」などでしか使わない（メモリリークに注意）。
	quickTick := time.Tick(2 * time.Second)

	// 4. time.After: 指定時間後に1回だけ実行（簡易版）
	// 使い捨てのチャネルを返す。select文のタイムアウト処理の定番。
	// 内部的には Timer を作っているが、制御（Stop）はできない。

	done := make(chan bool)
	go func() {
		time.Sleep(7 * time.Second) // 7秒後に全体を終了させる
		done <- true
	}()

	fmt.Println("待機中...")

loop:
	for {
		select {
		case t := <-heartbeat.C:
			// Ticker: 1秒ごとに繰り返し実行される
			fmt.Printf("[Ticker] 1秒経過: %s\n", t.In(jst).Format("15:04:05"))

		case t := <-quickTick:
			// Tick: 2秒ごとに繰り返し実行される（止める手段がないので注意）
			fmt.Printf("[Tick]   2秒周期の通知: %s\n", t.In(jst).Format("15:04:05"))

		case t := <-delayedJob.C:
			// Timer: 5秒後に一度だけ実行される
			fmt.Printf("[Timer]  5秒経ったので一度だけ仕事しました: %s\n", t.In(jst).Format("15:04:05"))

		case t := <-time.After(3 * time.Second):
			// After: この select が呼ばれてから「3秒間、他のケースが一度も成立しなかったら」動く
			// ※このコードでは他のケースが頻繁に動くため、ここには到達しにくい
			fmt.Printf("[After]  3秒間の沈黙がありました: %s\n", t.In(jst).Format("15:04:05"))

		case <-done:
			// 終了信号
			fmt.Println("--- 全ての処理を終了します ---")
			break loop
		}
	}
}
```

|**経過時間**|**実行される処理**|**理由・解説**|
|---|---|---|
|**0秒**|**「待機中...」表示**|`main`関数のループが開始されます。|
|**1秒**|**[Ticker] 1秒経過**|`heartbeat`（1秒周期）が最初に反応します。|
|**2秒**|**[Ticker]** & **[Tick]**|1秒周期と2秒周期が同時に重なります。`select`で順番に選ばれます。|
|**3秒**|**[Ticker] 1秒経過**|3回目の1秒周期が反応します。|
|**4秒**|**[Ticker]** & **[Tick]**|4回目の1秒周期と2回目の2秒周期が反応します。|
|**5秒**|**[Ticker]** & **[Timer]**|1秒周期と、**一度切りの5秒タイマー**が同時に反応します。|
|**6秒**|**[Ticker]** & **[Tick]**|6回目の1秒周期と3回目の2秒周期が反応します。|
|**7秒**|**全ての処理を終了**|`go func`内の`time.Sleep(7)`が終わり、`done`チャネルに信号が入るため、`break loop`します。|

#### ==`encoding/json`==
jsonというタグ名を使って、JSONのフィールドを指定し、これを使って、構造体のフィールドとマッチングします
タグがない場合は、デフォルトでJSONオブジェクトのフィールド名がGoの構造体のフィールド名とマッチングされますが明示的に指定しましょう

GoとJSONの間の相互に変換する機能が含まれています
- Go->JSON：マーシャリング
- JSON->GO：アンマーシャリング

##### 構造体タグ「バッククォート」で囲んで使う
- 構造体タグを使ってデータを処理するための規則を指定する
- 構造体タグは1行に書く
- 一つ以上の「タグ名と値のペア」からなり、各ペアは「タグ名：値」の形式で書かれ、各ペアは空白で区切られる
- フィールド名は大文字で始めるので、全てのフィールドがエクスポートされる
- 構造体タグは単純な文字列なので、コンパイラによる形式の検証はできない。ただし、「go vet」を使った検証をできる

|**タグの設定**|**マーシャリング (Go → JSON)**|**アンマーシャリング (JSON → Go)**|
|---|---|---|
|**`json:"name"`**|常に `name` キーで出力|`name` キーがあれば代入|
|**`json:"-"`**|**絶対に出力しない**|**絶対に代入しない**（常にゼロ値）|
|**`json:"name,omitempty"`**|値が空ならキーごと消す|`name` キーがあれば代入（通常と同じ）|
|**`json:"-,"`**|`"-"` という名前のキーで出力|`"-"` というキーがあれば代入|

>[!TIP] もし「JSONにある `"-"` という名前のキーを読み込みたい」という特殊な場合は、`json:"-,"`（カンマを付ける）と書く必要があります。


```go
type Order struct {
	ID          string    `json:"id"`
	DateOrdered time.Time `json:"date_ordered"`
	CustomerID  string    `json:"customer_id"`
	Items       []Item    `json:"items"`
}

type Item struct {
	ID       string `json:"id"`
	Name     string `json:"name"`
	Price    int    `json:"-"`
	Quantity int    `json:"quantity, omitempty"`
}
```

##### `Marshal` と `Unmarshal` 
「Goのデータ構造」と「JSON形式のテキスト」を相互に変換する機能

###### Marshal（マーシャル）：GoからJSONへ
Goの構造体やスライスを、JSONフォーマットの文字列（バイト列）に変換します。
- **ポイント:** フィールド名は大文字で開始（Exported）されている必要があります。小文字で始めるとJSONに出力されません。
- **整形して出力:** `json.MarshalIndent(u, "", " ")` を使うと、改行やインデントが付いた読みやすいJSONになります。
```go
package main

import (
	"encoding/json"
	"fmt"
)

type User struct {
	Name string `json:"name"`
	Age  int    `json:"age"`
}

func main() {
	u := User{Name: "Taro", Age: 25}

	// Marshalは []byte（バイト列）と error を返す
	jsonData, err := json.Marshal(u)
	if err != nil {
		fmt.Println(err)
		return
	}

	fmt.Println(string(jsonData)) // {"name":"Taro","age":25}
}
```

###### Unmarshal（アンマーシャル）：JSONからGoへ
JSON形式のデータを、Goの構造体などに流し込みます。
```go
func main() {
	// 外部から届いたJSONデータ（という想定）
	input := []byte(`{"name":"John","age":30}`)

	var u User

	// 第2引数は「ポインタ」で渡す必要がある
	err := json.Unmarshal(input, &u)
	if err != nil {
		fmt.Println(err)
		return
	}

	fmt.Printf("名前: %s, 年齢: %d\n", u.Name, u.Age)
}
```

|**操作**|**関数**|**渡すもの**|**戻り値**|
|---|---|---|---|
|**Go → JSON**|`json.Marshal(v)`|構造体そのもの|`([]byte, error)`|
|**JSON → Go**|`json.Unmarshal(data, &v)`|JSONデータ(byte)と**ポインタ**|`error`|

##### JSONのリーダーとライター
Goの `encoding/json` パッケージには、変換の方法が2系統あります。これらは「データをどこから読み書きするか」によって使い分けます。

###### Marshal/Unmarshal と Encode/Decode の違い
一言でいうと、**「メモリ上の変数」を相手にするか、「ストリーム（データ回路）」を相手にするか**の違いです。

| **種類**                  | **対象**                    | **主な用途**                                                                 |
| ----------------------- | ------------------------- | ------------------------------------------------------------------------ |
| **Marshal / Unmarshal** | `[]byte` (バイト列)           | すでにメモリ上にある小さなデータを変換する場合                                                  |
| **Encode / Decode**     | `io.Reader` / `io.Writer` | ネットワーク通信(HTTP)、ファイル、標準入出力など、**流れてくるデータ**を直接扱う場合<br>複数行のJSON構造体を読み書きする場合も |

###### Decode（デコード）の使い方
```go
package main

import (
    "encoding/json"
    "fmt"
    "strings"
)

type User struct {
    Name string `json:"name"`
}

func main() {
    // 例：ネットワークやファイルから流れてくるデータをシミュレート
    s := `{"name": "Taro"}`
    reader := strings.NewReader(s) // io.Readerを作成

    var u User
    // デコーダーを作成して、そのまま変数に流し込む
    err := json.NewDecoder(reader).Decode(&u)
    
    if err != nil {
        fmt.Println("エラー:", err)
    }
    fmt.Println(u.Name) // Taro
}
```

###### Encode（エンコード）の使い方

`json.NewEncoder` を使います。変換した結果をそのままファイルやHTTPレスポンスに書き出すことができます。
```go
func main() {
    u := User{Name: "Jiro"}

    // 標準出力（画面）に直接JSONを書き出す例
    // os.Stdout は io.Writer を満たしている
    encoder := json.NewEncoder(os.Stdout)
    encoder.SetIndent("", "  ") // 整形の設定も可能
    
    encoder.Encode(u) 
    // 実行すると画面に以下が出る：
    // {
    //   "name": "Jiro"
    // }
}
```


#### ==`net/http`==
GoはHTTP/2のクライアントとサーバーが含まれている

##### HTTPクライアント
HTTPリクエストの生成およびレスポンスの受信ができます。
デフォルトのクライアントのインスタンスはDefaultClientがパッケージnet/httpに含まれていますが、デフォルトでは、タイムアウトがないため本番環境での使用は避けるべき
その代わり独自のインスタンスを生成します。
プログラム全体でhttp.clientを一つだけ生成すれば大丈夫で、ゴルーチンを跨いだ複数の同時リクエストを適切に処理してくれます

```go
// 新しいインスタンスを生成して、Timeout設定
client := http.Client{
	Timeout: 30 * time.Second, // 30秒でタイムアウト
}
```

**リクエストを送りたい時は、 `http.NewRequestWithContest` を使用 **

新しいインスタンスを生成し、コンテキスト、メソッド、接続先のURLを渡します。
「PUT」「POST」「PATCH」のいずれかのリクエスト行う場合は、最後の引数に「io.Reader」として、リクエストのボディを指定します。（ない場合はnil）

```go
package main

import (
	"context"
	"encoding/json" // 1. jsonパッケージを追加
	"fmt"
	"net/http"
	"time"
)

// 2. 受け取るデータの形に合わせた構造体を定義
type Todo struct {
	UserID    int    `json:"userId"`
	ID        int    `json:"id"`
	Title     string `json:"title"`
	Completed bool   `json:"completed"`
}

func main() {
	client := http.Client{
		Timeout: 30 * time.Second,
	}

	url := "https://jsonplaceholder.typicode.com/todos/1"
	req, err := http.NewRequestWithContext(context.Background(), http.MethodGet, url, nil)
	if err != nil {
		panic(err)
	}

	req.Header.Add("X-My-Client", "Learning Go")
	res, err := client.Do(req)
	if err != nil {
		panic(err)
	}

	// 3. 【最重要】関数が終わるときに必ずBodyを閉じる
	defer res.Body.Close()

	// 4. json.NewDecoder を使って、レスポンスボディを直接構造体にデコードする
	var todo Todo
	if err := json.NewDecoder(res.Body).Decode(&todo); err != nil {
		panic(err)
	}

	// 5.レスポンスのステータスコードをチェック
	if res.StatusCode != http.StatusOK {
		panic(fmt.Errorf("status code error: %d", res.StatusCode))
	}

	// 6. レスポンスのHeaderのContent-Typeをチェック
	fmt.Println(res.Header.Get("Content-Type"))

	// 7. 結果を表示
	fmt.Printf("--- 取得結果 ---\n")
	fmt.Printf("ID: %d\n", todo.ID)
	fmt.Printf("タイトル: %s\n", todo.Title)
	fmt.Printf("完了フラグ: %v\n", todo.Completed)
}

```

##### HTTPサーバー
サーバー機能の中心には構造体のhttp.Serverとインタフェースhttp.Handerがある
Http.Serverはリクエストを受信する役割
TLS（Transport Layer Security）をサポートするパフォーマンスの高いHTTP/2サーバー
サーバーへのリクエストは、構造体http.serverのフィールドHandlerに代入されたインタフェースhttp.Handlerの実装によって処理される

- Hander
インタフェースhttp.Handlerは一つだけメソッドを定義します

- ResponseWriter
1. まずHeaderを呼び出して、http.Headerのインスタンスを取得し、必要なレスポンスヘッダーを設定する。ヘッダーを設定する必要がなければ呼び出す必要がない
2. 次にレスポンスのHTTPステータスコードを指定して、WriteHeaderを呼び出す（ステータスコードは定数として定義されている）ステータスコードが200のレスポンスを送信する場合は、WriteHeaderを省略できる
3. 最後にWriteを呼び出して、レスポンスのボディを設定する

```go
type Handler interface {
	ServeHTTP(http.ResponseWriter, *http.Request)
}

// http.ResponseWriterの型
type ResponseWriter interface {
	Header() http.Header
	Write([]byte) (int, error)
	WriteHeader(status.Code int)
}
```

###### `http.Server` 主要フィールドの解説
- **`Addr` (アドレス)**
    - **役割:** サーバーが「どのネットワークインターフェース」の「どのポート番号」で接続を待ち受けるかを指定します。
    - **書き方:** 一般的に `":8080"` のように記述します。
        - コロンの前を空にすると、PC上のすべてのネットワーク（ローカルホストやWi-Fi経由など）からのアクセスを許可します。
        - `"127.0.0.1:8080"` と書くと、そのPC自身（自分自身）からのアクセスのみを許可するセキュアな設定になります。
- **`Timeout` (タイムアウト関連)** サーバーがリソースを使い果たしてダウンするのを防ぐための「期限」設定です。
    - **`ReadTimeout`**: クライアントからリクエスト（ヘッダーとボディ）をすべて読み切るまでの制限時間です。これが短いと、巨大なファイルのアップロードなどが途中で切断されます。
    - **`WriteTimeout`**: サーバーがレスポンスの書き込みを開始してから終了するまでの制限時間です。
    - **`IdleTimeout`**: 「Keep-Alive」が有効な場合、次のリクエストが来るまで接続を維持する最大時間です。これを適切に設定することで、使われていない接続を自動で切り、新しい接続のために枠を空けることができます。
- **`Handler` (ハンドラー)**
    - **役割:** 届いたすべてのHTTPリクエストを処理する「窓口（司令塔）」を指定します。
    - **仕組み:** `http.Handler` インターフェース（`ServeHTTP` メソッドを持つ型）を満たすオブジェクトを渡します。
    - **動作:** サーバーにリクエストが届くと、Goはこの `Handler` に登録された `ServeHTTP` メソッドを自動的に呼び出します。今回のコードでは `HelloHandler` がその役割を担っています。

```go
package main

import (
	"encoding/json" // 1. パッケージを追加
	"fmt"
	"net/http"
	"time"
)

type HelloHandler struct{}

// メソッド名を ServerHTTP から ServeHTTP に修正
func (h HelloHandler) ServeHTTP(w http.ResponseWriter, r *http.Request) {
	// 2. レスポンスヘッダーの設定 (w.Writeの前に呼ぶ必要があります)
	w.Header().Set("Content-Type", "application/json")

	// 3. encoding/json を使って構造体やマップを直接書き込む
	data := map[string]string{"message": "Hello, World!"}

	// NewEncoder(w).Encode() を使うと、JSON変換と書き込みを同時に行えます
	if err := json.NewEncoder(w).Encode(data); err != nil {
		w.WriteHeader(http.StatusInternalServerError)
		return
	}
}

func main() {
	s := http.Server{
		Addr:         ":8080", // サーバー
		ReadTimeout:  30 * time.Second,
		WriteTimeout: 30 * time.Second,
		IdleTimeout:  30 * time.Second,
		Handler:      HelloHandler{}, // ServeHTTPを実装したのでエラーが消えます
	}

	fmt.Println("Server is running on port 8080...")
	err := s.ListenAndServe()
	if err != nil && err != http.ErrServerClosed {
		panic(err)
	}
}
```

###### `http.NewServeMux`
「HTTPリクエストのルーター（振分け機）」
`ServeMux` を使うことで、「`/hello` ならこの処理」「`/bye` ならあの処理」といった具合に、**URLのパスに応じて処理を分ける**ことができるようになります。

**http.ServeMux の主な役割と特徴**
- **マルチプレクサ (Multiplexer) の略:** 「複数の入力から一つを選んで出力する」という意味です。HTTPの世界では、**「届いたURLパス」を見て「実行すべきハンドラー」を選択する**役割を担います。
- **パスのルーティング:** 特定のURLパターン（例: `/users/`）を登録し、それに対応する関数や構造体を紐付けます。
- **最長一致の法則:** もし `/images/` と `/images/icons/` という2つのパスが登録されている場合、`/images/icons/logo.png` というリクエストが来たら、より長く一致する方の処理を優先的に実行してくれます。

**2種類の登録メソッド**
`ServeMux` には、処理を登録するための方法が主に2つあります。
1. **`HandleFunc(pattern, handlerFunc)`**: 第2引数に「関数」を直接渡します。手軽に書けるため、小規模な処理によく使われます。
2. **`Handle(pattern, handler)`**: 第2引数に「`http.Handler` インターフェースを満たす構造体」を渡します。状態を保持したい場合や、複雑な共通処理を持たせたい場合に便利です。

```go
package main

import (
	"fmt"
	"net/http"
	"time"
)

func main() {
	// 1. ServeMuxのインスタンス（ルーター）を作成
	mux := http.NewServeMux()

	// 2. パスごとに処理を登録
	// 関数を登録するパターン (HandleFunc)
	mux.HandleFunc("/hello", func(w http.ResponseWriter, r *http.Request) {
		fmt.Fprint(w, "こんにちは！")
	})

	mux.HandleFunc("/bye", func(w http.ResponseWriter, r *http.Request) {
		fmt.Fprint(w, "さようなら！")
	})

	// 3. サーバーの設定
	s := http.Server{
		Addr:         ":8080",
		Handler:      mux, // ここに作成したルーターを渡す
		ReadTimeout:  10 * time.Second,
		WriteTimeout: 10 * time.Second,
	}

	fmt.Println("Server starts with routes: /hello, /bye")
	s.ListenAndServe()
}
```

###### 関連するhttp.ServeMuxのインスタンスを複数生成し、親に登録

```go
package main

import (
	"fmt"
	"net/http"
)

func main() {
	// --- 1. 子ルーター (API用) を作成 ---
	apiMux := http.NewServeMux()
	apiMux.HandleFunc("/users", func(w http.ResponseWriter, r *http.Request) {
		fmt.Fprint(w, "API: ユーザー一覧")
	})
	apiMux.HandleFunc("/health", func(w http.ResponseWriter, r *http.Request) {
		fmt.Fprint(w, "API: ヘルスチェックOK")
	})

	// --- 2. 親ルーター を作成 ---
	parentMux := http.NewServeMux()

	// 親に子を登録する
	// ※ http.StripPrefix を使うのが一般的（後述）
	parentMux.Handle("/api/", http.StripPrefix("/api", apiMux))

	// 親独自のルート
	parentMux.HandleFunc("/", func(w http.ResponseWriter, r *http.Request) {
		fmt.Fprint(w, "ここはメインページです")
	})

	fmt.Println("Server running on :8080...")
	http.ListenAndServe(":8080", parentMux)
}
```

##### ミドルウェア
HTTPサーバーの一般的な要件の一つに、複数のハンドラにまたがって一連のアクションを実行することがあります。

`http.Handler` を受け取り、新しい `http.Handler` を返す関数を作成し、通常返される、http.Handlerはhttp.HandleFuncに変換されるクロージャーです

```go
func MyMiddleware(next http.Handler) http.Handler {
    return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
        // 1. 前処理 (例: 認証チェック、ログ記録の開始)
        fmt.Println("Before request")

        // 2. 本体の処理を実行
        next.ServeHTTP(w, r)

        // 3. 後処理 (例: 処理時間の記録、ログ出力)
        fmt.Println("After request")
    })
}
```

###### 実践的な例：ロギング・ミドルウェア
```go
package main

import (
	"fmt"
	"net/http"
	"time"
)

// ミドルウェアの定義
func Logger(next http.Handler) http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		start := time.Now()

		// 本体の処理を実行
		next.ServeHTTP(w, r)

		// 処理が終わった後にログを出す
		fmt.Printf("[%s] %s %s\n", r.Method, r.URL.Path, time.Since(start))
	})
}

func main() {
	mux := http.NewServeMux()

	// メインのハンドラー
	helloHandler := http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		fmt.Fprint(w, "Hello, Middleware!")
	})

	// ハンドラーをミドルウェアで包んで登録
	mux.Handle("/", Logger(helloHandler))

	fmt.Println("Server starts with Logger middleware on :8080")
	http.ListenAndServe(":8080", mux)
}
```

###### 複数のミドルウェアを連結
```go
// 共通ヘッダーを付与するミドルウェア
func CommonHeader(next http.Handler) http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		w.Header().Set("Content-Type", "application/json")
		next.ServeHTTP(w, r)
	})
}

// 連結して使用
// Logger -> CommonHeader -> helloHandler の順に実行される
wrappedHandler := Logger(CommonHeader(helloHandler))
mux.Handle("/api/", wrappedHandler)
```

##### サーバ強化のためのサードパーティモジュールの追加
ミドルウェアのファンクションチェーンが気に入らない場合は、「alice」というサードパーティモジュールを使える

```go
// aliceを使うとこのように書ける
chain := alice.New(Logger, Recoverer, Auth).Then(myHandler)
```

##### `ResponseController`
Go 1.20から導入された比較的新しいツールで、「HTTPレスポンスの高度な制御を、安全かつ簡単に行うための仕組み」です。

一言でいうと、標準の `http.ResponseWriter` だけでは手が届かなかった **「タイムアウトの個別延長」や「データの即時送信（Flush）」などを、一つの窓口で操作できるリモコン** のようなものです。

###### ResponseController でできる主なこと
主に以下の4つの操作を一つのインスタンスで行えます。
① Flush（即時送信）
バッファに溜まっているデータを、即座にクライアントへ送り出します。
- **用途:** 巨大なファイルを少しずつ送る場合や、チャット、**Server-Sent Events (SSE)** の実装に必須です。
② SetReadDeadline / SetWriteDeadline（個別の期限設定）
サーバー全体の設定（`ReadTimeout` など）とは別に、**「このリクエストだけは特別に時間をかけたい（または短くしたい）」** という場合に、通信の締め切り時間を動的に変更できます。
③ Hijack（接続の乗っ取り）
HTTPの管理下からTCP接続を切り離し、独自のプロトコル（WebSocketなど）にアップグレードするために使用します。
```go
func handler(w http.ResponseWriter, r *http.Request) {
    // ResponseControllerを作成
    rc := http.NewResponseController(w)

    for i := 0; i < 5; i++ {
        fmt.Fprintf(w, "データその %d...\n", i)

        // タイムアウトをリクエスト中に延長する（例：さらに10秒待てるようにする）
        rc.SetWriteDeadline(time.Now().Add(10 * time.Second))

        // 即座にクライアントへ送信
        if err := rc.Flush(); err != nil {
            return
        }
        
        time.Sleep(1 * time.Second)
    }
}
```

###### 実装例
```go
package main

import (
	"fmt"
	"net/http"
	"time"
)

func streamHandler(w http.ResponseWriter, r *http.Request) {
	// 1. ResponseControllerの作成
	rc := http.NewResponseController(w)

	// 2. SSE用のヘッダーを設定
	w.Header().Set("Content-Type", "text/event-stream")
	w.Header().Set("Cache-Control", "no-cache")
	w.Header().Set("Connection", "keep-alive")

	for i := 1; i <= 5; i++ {
		// データを書き込む
		fmt.Fprintf(w, "data: メッセージ %d番目 (時刻: %s)\n\n", i, time.Now().Format("15:04:05"))

		// 3. Flushで即座にクライアントへ送信
		err := rc.Flush()
		if err != nil {
			fmt.Println("クライアントが切断されました")
			return
		}

		// 1秒待機
		time.Sleep(1 * time.Second)
	}
}

func main() {
	http.HandleFunc("/stream", streamHandler)
	fmt.Println("Server started at :8080. Access http://localhost:8080/stream")
	http.ListenAndServe(":8080", nil)
}
```

#### ==構造化ログ==
構造化ログを簡単に実装ができるのが「log/slog」
Go 1.21から標準ライブラリに追加された「構造化ロギング（Structured Logging）」のためのパッケージです。

これまでGoの標準にはシンプルな `log` パッケージしかありませんでしたが、本番環境の運用に耐えうる「解析しやすいログ」を出力するために、ついに標準化された強力なツールです。

従来のログは「ただの文字列」でしたが、構造化ログは **キーと値のペア（Key-Value）** でログを出力します。

| **ログの種類**        | **出力例**                                                                              | **メリット/デメリット**                                      |
| ---------------- | ------------------------------------------------------------------------------------ | --------------------------------------------------- |
| **従来のテキストログ**    | `2026/01/04 10:00:00 ERROR login failed for user 123`                                | 人間には読みやすいが、機械（検索ツール）での分析が困難。                        |
| **構造化ログ (JSON)** | `{"time":"2026-01-04T10:00:00Z","level":"ERROR","msg":"login failed","user_id":123}` | **CloudWatchやDatadogなどのツールで、特定のユーザーIDだけを爆速で検索できる。** |

##### slog の 3 つの主要コンポーネント
`slog` を理解するには、以下の3つの役割を押さえるのが近道です。
1. **Logger (ロガー):** 私たちがコードの中で `slog.Info()` などと呼び出す入り口です。
2. **Record (レコード):** ログ一行分のデータ（メッセージ、時刻、レベルなど）を持つ中身です。
3. **Handler (ハンドラー):** **ここが最も重要です。** レコードを「JSONにするか」「テキストにするか」「どこに出力するか」を決定するエンジンです。

##### 使い方
```go
package main

import (
	"log/slog"
	"os"
)

func main() {
	// --- 1. JSON形式で出力する設定 (Handlerの作成) ---
	handler := slog.NewJSONHandler(os.Stdout, nil)
	logger := slog.New(handler)

	// --- 2. ログを出力する ---
	// メッセージの後に「キー, 値」の順番で並べるだけ
	logger.Info("ユーザーがログインしました",
		"user_id", 123,
		"status", "success",
	)
}
```

##### クリーンアーキテクチャにおける活用
クリーンアーキテクチャでは、**「Context（コンテキスト）」**にリクエストIDなどを仕込み、それをミドルウェア経由で `slog` に渡すことで、一つのリクエストに関するログをすべて数珠繋ぎに追跡できるようになります。

```go
// コンテキストから情報を抽出してログに付与する例
logger.InfoContext(ctx, "処理開始")
```