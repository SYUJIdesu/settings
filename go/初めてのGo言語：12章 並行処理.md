---
up: "[[初めてのGo言語]]"
related:
tags:
  - golang
aliases:
  - golang
created: 2025-12-31
updated: 2025-12-31
---
### 概要

「並行処理」または「並行性」は、「一つの処理を独立した複数のコンポーネントに分割し、コンポーネント間で安全にデータを共有しながら計算すること」
多くの言語はライブラリを介して、OSレベルのスレッドによって、ロックを使い、データを共有していますが、Goは**CSP**（Communication Sequential Process）に基づいて行なっている
### 詳細

#### ==並列処理を行うタイミング==
何でもかんでも並列処理にしない。
重要なのは、「並行性は並列性とは違う」と言う点です。並列性は解決対象の問題を、より自然に表現するためのツールなのです。

全てのプログラムは、「データを取り込み、変換し、結果を出力する」と言う同じ3つのステップを踏みます。
並列性を利用すべきなのは、「独立に実行できる複数の処理」がある場合です。

<mark style="background: #FF5582A6;">※注意点</mark>
並列に実行される処理が長い時間を要さない場合は、並行性は利用するに値しないと言う点です。
> [!info] 並列性を利用した方がわからない場合は、コードを逐次的に書き、並行性を利用した実装とパフォーマンスを比較するベンチマークを作成してください。


#### ==ゴルーチン==
「**Goのランタイムによって管理される軽いスレッド**」です。
Goのプログラムが、開始される時、Goのランタイムはプログラムを実行するために、いくつかのスレッドを生成し一つのゴルーチンを起動する。

プログラムによって生成された全てのゴルーチンはGoのランタイムスケジューラによってこうしたスレッドに割り当てらる。
※OSがCPUのコアごとにスレッドをスケジュールするときに同じようになる

>[!info]
> - ゴルーチンの生成はスレッドの生成よりも速い。OSレベルのリソースを生成しているのではないため
> - ゴルーチンの当初のスタックサイズはスレッドのスタックサイズよりも小さくなる。そして必要に応じて大きくできる。これによりゴルーチンはメモリを効率的に利用することになる
> - ゴルーチンのスイッチングの方がスレッドのスイッチングよりも速い。一つのプロセス内で行われるので、（比較的）遅いシステムコールを回避できるため
> - 同一プロセス内の処理になるため、スケジューリングを最適化できる。スケジューラはネットワークボーラと協同し、I/O でブロックしているゴルーチンを対象から外すべき時を検知できる。また、ガベージコレクタとも統合されているため、Goのプロセスに割り当てられた全てのOSのスレッドに対して必要な処理が適切に割り当てられるようにできる

##### プロセス
具体的なプログラムがOSによって実行されているものです。
OSは何らかのリソースをプロセスと関連付け、他のプロセスがそうしたリソースにアクセスできないようにします。

##### スレッド
一つのプロセスは、一つ以上のスレッドから構成されます。
スレッドは、実行の単位で、OSから決められた時間が与えられて実行されます。
一つのプロセス内での、一つまたは複数のスレッドがリソースへのアクセスを共有します。
一つのCPUは同時に一つあるいは、複数のスレッドの命令を実行できます。（コアの数に依存）
OSの一つの仕事はスレッドの処理をスケジュールすることです。全てのプロセス（スレッド含む）が実行されるようにする必要がある

```go
package main

import (
	"fmt"
)

func doBusiness(val int) int { // ビジネスロジック
	return val * 2
}

func runThingCouncurrently(chIn <-chan int, chOut chan<- string) {
	for val := range chIn { // inチャネルから値を受信
		go func(val int) { // 新たにgoroutineを呼び出す
			result := doBusiness(val)                            // ビジネスロジックを実行
			chOut <- fmt.Sprintf("入力値: %d, 結果: %d", val, result) // 結果をoutチャネルに送信
		}(val) // chInから読んだ値を無名関数の引数として渡して実行
	}
}

func main() {
	chIn := make(chan int, 5)  //intのチャネルを生成。送信用
	chOut := make(chan string) // stringのチャネルを生成。受信用
	go runThingCouncurrently(chIn, chOut)

	vals := []int{1, 2, 3, 4, 5}
	for _, val := range vals { // valsの各要素をchInに送信
		chIn <- val
	}

	i := 0
	for result := range chOut { // chOutから受信
		fmt.Println(result) // 結果を表示 順番は不定
		i++
		if i >= len(vals) { //送った要素の数と同じ回数受信したら終了
			break
		}
	}

	close(chOut) // chOutを閉じる（なくても大丈夫）
	close(chIn)  // chInを閉じる（同上）
}

```


#### ==チャネル==
ゴルーチンでは情報のやり取りをチャネルを使う
「ゴルーチン（並列処理）同士がデータを安全に受け渡しするための専用パイプ」です。
Goの設計思想である「メモリを共有することで通信するのではなく、通信することでメモリを共有せよ」を具現化した仕組みです。

生成する際には　`make` 関数にキーワード `chan` とチャネルでやり取りする型を指定します
`ch := make(chain, int)` 
マップ同様、チャネルは参照型です。
関数にチャネルを渡すとき、実際にはチャネルへのポインタを渡すことになります。
また、チャネルのゼロ値は、 `nil` です。（マップやスライスと同じ）

##### 読み込み、書き込み、バッファリング
チャネルとのやりとりは「<-」演算子（オペレータ）を使う
- 読み込み：チャネル変数の左側に「<-」
	- `ch <- chan int`
- 書き込み：チャネル変数の右側に「<-」
	- `ch chan<- int`

###### バッファリング（Buffering）
チャネルの中に「データを一時的に溜めておける保管場所（バッファ）」
ほとんどの場合は必要がない
バッファリングされるチャネルに関しては次の2種類がある
- cap：キャパシティ（最大いくつバッファリングできるか）返す
- len：現在バッファ内にある値の個数を返す

##### `for - range` チャネル
`for - range` を使用してチャネルからの読み込みを行うことが可能

`for - range` が終了するタイミング
- チャネルがクローズされる
- `break` 文あるいは `return` 文が実行された
```go
for val := ch { // チャネルからの読み込みを行うことができ
}
```

##### チャネルのクローズ
チャネルのクローズの責任はチャネルに書き込むゴルーチンにある
クローズはチャネルがクローズするのを待っているゴルーチンがある時のみに、必須である点に注意してください
チャネルも変数だからガベージコレクションがある
ただこのやりとりが「データフロー」の理解をややこしくしている

チャネルへの書き込みが終わったらクローズする
`close(ch)` 

「カンマ ok イディオム」を使用して「チャネルに書き込まれて戻されたゼロ値」と「チャネルがクローズされていたために戻されたゼロ値を」とを区別可能
`v, ok := <-ch`
`true`：オープンな状態
`false`：クローズな状態

##### チャネルの動作
チャネルには状態があり、読み込み、書き込み、クローズを行ったときの振る舞いが異なる
複数のゴルーチンが同じチャネルを参照書き込みは気を付ける

| チャネル | バッファ無+開     | バッファ無+閉               | バッファ有+開          | バッファ有+閉                           | nil    |
| ---- | ----------- | --------------------- | ---------------- | --------------------------------- | ------ |
| 読み込み | 書き込まれるまでポーズ | ゼロ値を返す（カンマokイディオムを使用） | バッファが空ならばポーズ     | バッファに残されている値を戻す。バッファがからの場合、ゼロ値を返す | 無限にハング |
| 書き込み | 読み込まれるまでポーズ | パニック                  | バッファが一杯ならポーズ     | パニック                              | 無限にハング |
| クローズ | クローズする      | パニック                  | 残りの値はそのままでクローズする | パニック                              | パニック   |
#### ==select==
`SELECT` はGoにおける並行性の制御構造そのもので、並行操作の優先順にまつわる問題をエレガントに解決します
各チャネルを「公平」に扱わないとスタベーションが起こってしまうのです

##### selectとCASE
`select` を使うことで、`swtich` のように複数のチャネルをに対する記述の操作が可能になります
`case` はチャネルに対する読み込みと書き込みです。
ある `case` に対して両方どちらかが可能な場合に、その操作とcaseの本体が実行される

複数の `case` が同時に実行可能（データが届いている、または送信可能）な状態になった場合、**実行される `case` は「ランダム（一様擬似乱数的）」に選ばれます。**
```go
select {
	case v := <- ch1:
		// ch1から値を受信した場合の処理
	case v := <- ch2:
		// ch2から値を受信した場合の処理
	case ch3 <- 1:
		// ch3に値を送信した場合の処理
	default:
		// どのcaseにも該当しない場合の処理
}
```

##### デッドロックの回避
以下のように「デッドロック」のケースを`select` は解決してくれる
- 一方がチャネルch1から送信しようとし、もう一方がch2から受信しようとしている
- どちらも同じチャネルから送信しようとしている、あるいは同じチャネルから受信しようとしている

```go
ch1 := make(chan string)
ch2 := make(chan string)

go func() {
  ch1 <- "ゴルーチンから送信した文字列"
  fromMain := <-ch2
  fmt.Println("goroutine:", fromMain) //は実行されない
}()

var fromGoroutine string
select { // チャネルのやり取りをselectで囲む
case ch2 <- "mainから送信した文字列":
case fromGoroutine = <-ch1:
}
fmt.Println("main:", fromGoroutine)
```

##### `for - select` ループ
「複数のチャネルからの入力を待ち受け、それをずっと（あるいは特定の条件まで）繰り返す」ためのパターンです
```go
Loop: // ループに名前を付ける
    for {
        select {
        case <-done:
            break Loop // Loop という名前の for を抜ける
        case v := <-ch:
            fmt.Println(v)
        }
    }
```

#### ==並行処理のベストプラクティスとパターン==

##### APIに並行性を含めない
並行性は実装に関する詳細です。なので表に出さないようにする
具体的には、公開する型、関数、メソッドにチャネルを含めないようにする

##### ゴルーチンとforループ
Go 1.22でループの変数は変わる

|**バージョン**|**ループ変数の扱い**|**ゴルーチンでの挙動**|
|---|---|---|
|**Go 1.21 以前**|**ループ全体で1つ**の変数|全てのゴルーチンが**同じメモリ番地**を見るため、実行時の最新値（最終値）を参照してしまう。|
|**Go 1.22 以降**|**各回（イテレーション）ごと**に新しい変数|各ゴルーチンが**その時点の固有のコピー**を保持するため、期待通りの値が参照される。|

###### 以前
```go
values := []string{"a", "b", "c"}
for _, v := range values {
    go func() {
        fmt.Println(v) // 全てのゴルーチンが同じ「変数 v」を見ている
    }()
}
// 実行結果（期待に反して）: c c c（またはタイミングによりバラバラ）
```

###### 現在
```go
values := []string{"a", "b", "c"}
for _, v := range values {
    go func() {
        fmt.Println(v) // 各イテレーションの v は「別物」なので安全！
    }()
}
// 実行結果: a b c （順序は非同期なので入れ替わります）
```

##### ゴルーチンの終了チェック
ゴルーチンとして実行される関数を起動する際には確実に終了するようにしなければならない。変数と違い、Goのランタイムが「今後使われることがない」かどうかの検出できないゴルーチンが終了しない限りメモリに割り当てたらままになる
これを、**ゴルーチンリーク**と呼ぶ

##### コンテキストを使ったゴルーチンの終了
コンテキストを使用してゴルーチンに処理停止タイミングを伝えることができる

###### キャンセレーション
「もうこの処理は必要なくなった」という信号を、実行中の複数のゴルーチンへ一斉に伝える仕組みのことです。

###### 基本的な手順（3ステップ）
1. **Contextとキャンセル関数を作成する**: `context.WithCancel` などを使って、信号を送るための準備をします。
2. **ゴルーチンにContextを渡す**: 関数の第1引数として `ctx` を渡すのがGoの慣習です。
3. **`ctx.Done()` を監視する**: ゴルーチン内で `select` 文を使い、キャンセル信号が届いていないかチェックします。

```go
func countTo(ctx context.Context, max int) <-chan int {
	ch := make(chan int)

	go func() {
		defer close(ch)
		for i := 0; i < max; i++ {
			select {
			case <-ctx.Done():
				// キャンセル（クローズ）信号を検知したら、直ちにゴルーチンを終了
				return
			case ch <- i:
				// 受信側が準備できるまで値を送り続ける
			}
		}
	}()
	return ch
}

func main() {
	// 1. キャンセル信号を送るための「親機」と「停止ボタン」を作成
	ctx, cancel := context.WithCancel(context.Background())

	// 2. 関数終了時に必ずキャンセルを実行し、ゴルーチンの放置（リーク）を防ぐ
	defer cancel()

	ch := countTo(ctx, 10)
	for val := range ch {
		if val > 5 {
			// ループを抜けると関数が終了するため、defer cancel() が発動する
			break
		}
		fmt.Println(val)
	}
}
```

##### いつバッファ付きのチャネルを使うべきか
- Goの並列性のうち、バッファの扱いが一番難しい
- 無限サイズのバッファは使用できない
- バッファ付きのチャネルを正しく使うには、バッファがいっぱいになった場合（書き込みのゴルーチンが読み込み側のゴルーチンを待っている状態）にどう対処するかを記述しなければならない。

###### 有用例
- 起動するゴルーチンの数を制限したい
	- 起動した一群のゴルーチンからデータを集めたい場合
- バッファに入ったものの処理に制限をかけたい
	- 並列実行の「並行度」を制限したい場合

```go
func processChannel(ch chan int) []int {
	const max = 10
	results := make(chan int, max)
	for i := 0; i < max; i++ {
		go func() {
			val := <-ch
			results <- process(val)
		}()
	}
	var out []int
	for i := 0; i < max; i++ {
		out = append(out, <-results)
	}
	return out
}
```

##### バックプレッシャー
バッファ付きチャネルを使って実装できるもう一つのテクニックに**バックプレッシャー**がある
特定パートの仕事量を制限してシステムが全体として効率よく動作するよう、バッファ付きチャネルとselect文を使って同時リクエストの数を制限します

簡単に言うと、「処理が追いつかない受信側が、送信側に対して『送るスピードを落としてくれ！』と圧力をかけて制御すること」です。

システム間のデータ転送において、**「作る側（Producer）」が「使う側（Consumer）」よりも速い**ときに発生するパンクを防ぐための、非常に重要な「安全装置」です。

###### バッファありチャネル（クッション付きの圧力）
バッファ（保管場所）が一杯になると、送信側はストップします。
- バッファがある間は送信を許可するが、限界を超えたら送信側にブレーキをかける。
- これがまさに「バックプレッシャー」です。

```go
// 容量3のバッファ付きチャネル
ch := make(chan int, 3)
// 4つ目を送ろうとした瞬間、受信側が受け取るまで送信側の処理が止まる
ch <- 4
```

```go
// 圧力計
type pressureGauge struct {
	ch chan struct{} //構造体フィールドch
	// 型が「空の構造体」のデータを保持するチャネル
	//空の構造体はメモリを消費しない、「シグナル」として活用
}

// ファクトリ関数
// サイズlimitの pressure gauge を作成する
func New(limit int) *pressureGauge {
	return &pressureGauge{
		ch: make(chan struct{}, limit),
	}
}

// *PressureGauge pgを受け取って、それが許す範囲で関数fを実行する
func (pg *pressureGauge) Process(f func()) error {
	select {
	case pg.ch <- struct{}{}: //チャネルpg.chに書き込む
		f()     // Processに引数として渡された関数を実行
		<-pg.ch // pg.chから値をもらったが値を無視（シグナルとして受信）
		return nil
	default:
		return errors.New("pressure gauge is full")
	}
}

// 単に「2秒経ったら、完了を返す」という作業する
func doThing() string {
	time.Sleep(2 * time.Second)
	return "done"
}

func main() {
	pg := New(3) // 3つのgoroutineを同時に実行できる
	http.HandleFunc("/request", func(w http.ResponseWriter, r *http.Request) {
		err := pg.Process(func() {
			w.Write([]byte(doThing()))
			// stringを[]byteに変換
		})
		if err != nil {
			w.WriteHeader(http.StatusTooManyRequests)
			w.Write([]byte("リクエストが多すぎて捌ききれません"))
		}
	})

	fmt.Println("ブラウザで次を開いてださい: 'http://localhost:8000/request'")
	fmt.Println("あるいは、'sh ex1210.sh'を実行してください")
	http.ListenAndServe(":8000", nil)
}

```

##### selectにおける`case` の無効化
Goの `select` 文において特定の `case` を動的に「無効化」する最も標準的でクリーンな方法は、**そのチャネル変数を `nil` に設定すること**です。

Goの言語仕様では、「`nil` なチャネルに対する送受信は永久にブロックされる」という特性があります。`select` 文はこの特性を利用し、`nil` になった `case` を評価対象から外します（正確には、決して選択されない状態になります）。

例：
2つのチャネル `ch1` と `ch2` からデータを受け取り、両方がクローズされたら終了するプログラムを考えます。クローズされたチャネルを `nil` にしないと、`select` はクローズ済みのチャネルを何度も選んでしまい、無意味なゼロ値を読み続けてしまいます。
```go
package main

import "fmt"

func main() {
    ch1 := make(chan int)
    ch2 := make(chan int)

    // ダミーデータの送信
    go func() {
        ch1 <- 10
        close(ch1)
    }()
    go func() {
        ch2 <- 20
        close(ch2)
    }()

    for {
        // ch1 と ch2 の両方が nil になったらループを抜ける
        if ch1 == nil && ch2 == nil {
            break
        }

        select {
        case v, ok := <-ch1:
            if !ok {
                // チャネルがクローズされたら nil を代入して「無効化」
                fmt.Println("ch1 を無効化しました")
                ch1 = nil
                continue
            }
            fmt.Println("ch1 から受信:", v)

        case v, ok := <-ch2:
            if !ok {
                // チャネルがクローズされたら nil を代入して「無効化」
                fmt.Println("ch2 を無効化しました")
                ch2 = nil
                continue
            }
            fmt.Println("ch2 から受信:", v)
        }
    }
    fmt.Println("すべてのチャネルが終了しました")
}
```

##### タイムアウト
Goでの並行処理において、タイムアウトの実装は**「リソースの解放」**と**「ユーザー体験（UX）の向上」**のために必須のスキルです。

主に2つの方法がありますが、実務では **`context` パッケージ** を使うのが標準です。
単なる `select` による分岐だけでなく、「芋づる式に処理を止める」ことができるからです。
- **伝播性:** 親のコンテキストがタイムアウトすると、その `ctx` を渡しているすべての関数（DBクエリ、外部APIリクエストなど）も即座に中断されます。
- **標準ライブラリとの統合:** `http.NewRequestWithContext(ctx, ...)` のように使うことで、ネットワーク通信自体をタイムアウト時に強制終了できます。

```go
func main() {
    // 1. 2秒後に自動でキャンセルされるコンテキストを作成
    ctx, cancel := context.WithTimeout(context.Background(), 2*time.Second)
    defer cancel() // リソース解放のため必ず呼ぶ

    ch := make(chan string)

    go func() {
        time.Sleep(3 * time.Second) // 重い処理のシミュレーション
        ch <- "完了"
    }()

    select {
    case res := <-ch:
        fmt.Println(res)
    case <-ctx.Done():
        // タイムアウト理由（context deadline exceeded）を表示
        fmt.Println("タイムアウト:", ctx.Err())
    }
}
```

##### `WaitGroup` の利用
「複数のゴルーチンがすべて終了するのを待機するための仕組み（ゴルーチン完了を待つためのカウンタ）」

ゴルーチン（`go` 関数）は呼び出した瞬間にバックグラウンドへ投げられます。そのため、何も対策をしないと、「中身の処理が終わる前にメインの関数（main）が終了して、プログラム全体が消えてしまう」という現象が起きます。

これを防ぐために「全員終わるまでここで待ってて！」と指示を出すのが `WaitGroup` の役割です。

`sync` パッケージをインポートして、以下の3つの機能を使います。

|**メソッド**|**役割**|**イメージ**|
|---|---|---|
|**`Add(n)`**|待ちたいゴルーチンの数を設定する。|「今から $n$ 人が作業に入るよ」と登録。|
|**`Done()`**|作業が終わったことを報告する。|「自分の作業が終わったよ！」という完了報告。|
|**`Wait()`**|全員が終わるまでその場で待機する。|「全員の完了報告が揃うまで、ここを通さないよ」。|

**鉄則**
- Add はゴルーチンの「外」で呼ぶ
- Done は `defer` で呼ぶ
- 関数に渡すときは「ポインタ」で渡す

```go
func worker(id int, wg *sync.WaitGroup) {
	// 3. 終わったら必ず Done を呼ぶ（deferを使うのが定石）
	defer wg.Done()

	fmt.Printf("ワーカー %d: 開始\n", id)
	time.Sleep(time.Second) // 重い処理の代わり
	fmt.Printf("ワーカー %d: 完了\n", id)
}

func main() {
	var wg sync.WaitGroup

	for i := 1; i <= 3; i++ {
		// 1. ゴルーチンを起動する前にカウントを増やす
		// Add はゴルーチンの「外」で呼ぶのが鉄則
		wg.Add(1)
		go worker(i, &wg)
	}

	fmt.Println("メイン: ワーカーの終了を待っています...")

	// 2. 全員が Done() を呼ぶまでここでブロックされる
	wg.Wait()

	fmt.Println("メイン: 全員終わったので終了します。")
}
```

##### コードを一度だけ実行
Goにおいて「必要なときまで初期化を遅らせる」レイジーロード（遅延初期化）を実装する場合、最も重要になるのが並行処理下での安全性（スレッドセーフ）です。

Goの標準ライブラリには、これを非常にシンプルかつ安全に実現するためのツールが用意されています。

###### 定石：`sync.Once` を使う
実務で最も使われる方法です。複数のゴルーチンから同時にアクセスされても、「最初の1人だけが初期化を実行し、他の人は終わるまで待つ」という挙動を保証します。
```go
type Database struct {
    Connection string
}

var (
    dbInstance *Database
    once       sync.Once // ここがポイント
)

// GetDatabase は、必要になった瞬間に初めてインスタンスを作る
func GetDatabase() *Database {
    once.Do(func() {
        fmt.Println("重い初期化処理を実行中...")
        dbInstance = &Database{Connection: "Connected"}
    })
    return dbInstance
}

func main() {
    // 複数のゴルーチンから同時に呼んでも、初期化は1回だけ
    var wg sync.WaitGroup
    for i := 0; i < 5; i++ {
        wg.Add(1)
        go func(id int) {
            defer wg.Done()
            db := GetDatabase()
            fmt.Printf("Worker %d: %s\n", id, db.Connection)
        }(i)
    }
    wg.Wait()
}
```

##### mutex
Go言語は、他の多くの言語（Java, C++, Pythonなど）とは「並行処理に対する基本的な考え方」が根本的に異なります。

Goの設計者たちは、従来の「Mutex（鍵）で共有メモリを保護する」手法が、複雑なシステムではバグやデッドロックを招きやすいと考え、新しいアプローチを採用しました。

###### Goの有名な格言
Goの設計思想を象徴する言葉があります。
> **"Do not communicate by sharing memory; instead, share memory by communicating."** （共有メモリによって通信するのではなく、通信することによってメモリを共有せよ）
- **他の言語:** 同じ変数（メモリ）を複数のスレッドで見に行き、壊さないように「鍵（Mutex）」をかける。
- **Go言語:** データを「チャネル（通信）」に乗せて、次の担当者へ渡す。

###### 構造的な違いのイメージ
**従来の言語：共有メモリ + Mutex**
イメージは「1つのホワイトボード」です。
- 全員が同じボードに書き込もうとするため、誰かが書いている間は他の人を突き飛ばして（ロックして）待たせる必要があります。
- 鍵をかけ忘れると、内容がめちゃくちゃになります。

 **Go言語：メッセージパッシング（チャネル）**
イメージは**「バトンリレー」**です。
- データ（バトン）を持っているのは、常に走っている一人だけです。
- 次の人に渡してしまえば、自分はもうそのデータに触れません。
- 鍵をかけなくても、「持っている人だけが触る」というルールで安全が守られます。

##### クリティカルセクション
クリティカルセクション（Critical Section）は、プログラミングやOS（オペレーティングシステム）の概念で、「複数の処理が同時に触るとマズい、共有のリソースを操作しているコードの範囲」のことです。

プログラミング言語（Go, Java, C++, Pythonなど）に関わらず、並行処理（マルチスレッド）を行う上で避けては通れない、コンピュータサイエンスの基礎用語です。

##### sync/atomic
