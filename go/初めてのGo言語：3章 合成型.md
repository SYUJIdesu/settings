---
up: "[[初めてのGo言語]]"
related:
tags:
  - golang
aliases:
  - golang
created: 2025-12-18
updated: 2025-12-18
---
### 概要

合成型（composion type）について見ていきます。
またの名を、「コンポジット型」、「複合型」、「複合データ型」、「コンテナ型」

### 詳細

#### ==配列==
GOでは配列はあまり使われない
各要素は指定された型である必要がある

##### 3個の整数の配列の生成
```go
var x [3]int
```

##### 値も宣言する場合は、**配列リテラル**を使用
```go
var x = [3]int{10,20,30}
```

##### 「空き」がある配列を作る場合はindexとその値をを以下のように指定
```go
//                0     5番目は4    次は6     10番目は100  次は5
var x = [12]int{  1,    5: 4,      6,       10: 100,    5}
```

|**Index**|**0**|**1**|**2**|**3**|**4**|**5**|**6**|**7**|**8**|**9**|**10**|**11**|
|---|---|---|---|---|---|---|---|---|---|---|---|---|
|**値**|**1**|0|0|0|0|**4**|**6**|0|0|0|**100**|**5**|

##### 配列リテラルは、初期化に整数の代わりに「...」が使える
```go
var x = [...]int{1,2,3}
var y = [3]int{1,2,3}
//x ===  y true
```

##### 要素のアクセス
```go
x[0] = 10
x[0];
```

##### 配列の長さ
```go
var x[2][3]int // 長さ２の配列だが型は長さ3の整数配列

len(x) // 配列の長さを調べる
```


##### 配列がGOであまり使用されない理由
[3]intと[4]intでは型が異なるから
なのでサイズ固定でわかる場合のみの使用になる


#### ==スライス（可変長のスライス）==
スライスの型には、サイズが含まれません

```go
var x = []int{1,2,3}
var y = []int{1,5: 4, 6, 10; 100, 15}
x[0]// 1
```

##### 配列との違い
リテラル以外を使って宣言する場合
 スライスのゼロ値nilになる
 - 「値がない」ことを示す
 - nilに型はない
 - 型代入可能
 - 異なる型と比較可能
 - nilスライスには何も含まない

```go
var x []int //初期値 スライスのゼロ値nilになる
```

 スライスは「比較可能ではない」
 標準ライブラリ「slices」で比較可能

##### 関数

###### len
配列の長さを測る。nilは0になる

###### append
スライスの最後に要素を増やす
「...」演算子でスライスを展開可能
```go
var x = []int{1,2,3}
x = append(x,4, 5, 6)

var y = []int{4,5,6}
x = append(x, y...)
```

##### スライスのキャパシティ
キャパシティは、一言で言うと、**「そのスライスが、メモリの再確保（引越し）なしに、あとどれだけ伸びしろがあるか」** を表す数字です。

| **用語**     | **関数**   | **意味**                  | **例え（エレベーター）** |
| ---------- | -------- | ----------------------- | -------------- |
| **長さ**     | `len(s)` | 今、実際にデータが何個入っているか。      | 今乗っている人数（3人）。  |
| **キャパシティ** | `cap(s)` | **裏側の配列**に、最大あと何個まで入るか。 | 定員（10人）。       |

##### `append` した時の動き（超重要）
`append` でデータを追加するとき、キャパシティに余裕があるかどうかで挙動が激変します。
###### ケースA：余裕がある時 (`len < cap`)
- **動作**: 裏側の配列の空いている場所に値を書き込むだけ。
- **コスト**: **爆速**。
###### ケースB：余裕がない時 (`len == cap`)
これ以上データが入らないため、Goは自動的に以下の処理を行います（これが「スライスの拡張」です）。
1. **新しい広い土地（配列）** をメモリ上の別の場所に確保する（通常は今の2倍のサイズ）。
2. 古い配列のデータを、新しい配列に**全コピー**する（引越し）。
3. 新しいデータを書き込む。
4. スライスが参照する先を新しい配列に切り替える。
- **コスト**: **重い**（メモリ確保 ＋ コピー）。


##### ランタイム
Goのランタイムは、ビルド時に**実行ファイル（バイナリ）の中に静的に組み込まれます**。 あなたが書いたコードの裏で、常に「黒子」として動き続けています。

##### make
キャパシティをあらかじめ指定可能です
```go
x := make([]int, 5)　//長さ5 キャパシティ5のintのスライス

x := make([]int, 5, 10) //長さ5 キャパシティ10

x := make([]int, 0, 10)
x[0] //長さ0なので要素指定できない erroeになる
x := append(x, 1,2,3,4,5,)// appendで追加する

```

##### スライスのクリア
スライスの全要素をゼロ値にする関数clearが追加されました
```go
x := []string{"a", "b", "c"}
clear(x)
fmt.Println(x)
```

###### スライスの生成方法の選択
「どうすればスライスを大きくする回数を減らせるか」
- 大きくならない可能性の場合は、ゼロ値で初期化
- 初期値がある場合は、デフォルトを指定する
- 可変の場合は、makeを使用

長さ0で初期化して、指定してmakeを実行します

###### スライスのスライス
スライス式はスライスから別のスライスを指定
```go

[開始オフセット:終了オフセット]

x := []string{"a", "b", "c", "d"}
y := x[:2]
z := x[2:]
d := x[1:3]

fmt.Println(y) // [a b]
fmt.Println(z) // [c d]
fmt.Println(d) // [b c]
}

```

###### スライスの記憶領域の共有
サブスライスを切り出す際には、データのコピーを作成しているわけではない。
二つの変数がメモリを共有しているので、片方が変更すると影響が出る
```go
x := []string{"a", "b", "c", "d"}
y := x[:2]
z := x[1:]
x[1] = "y"
y[0] = "x"
z[1] = "z"

fmt.Println(x) // [x y z d]
fmt.Println(y) // [x y]
fmt.Println(z) // [y z d]

```

###### フルスライス
`slice[low : high : max]`
- **low**: 開始インデックス
- **high**: 終了インデックス（長さ `len` を決める）
- **max**: キャパシティの終了インデックス（容量 `cap` を決める）
- 新しいスライスのサイズは以下になる
	- **長さ (len):** `high - low`
	- **容量 (cap):** `max - low`
###### なぜこれが必要なのか？（最大のメリット）
一言で言うと、**「意図しないデータの書き換え（副作用）を防ぐため」** です。
通常のスライス操作だと、元の配列の「余ったキャパシティ」まで共有してしまうため、`append` したときに元の配列のデータを書き換えてしまうリスクがあります。フルスライス式を使うと、**「キャパシティを長さに合わせて制限（去勢）」** できるため、`append` した瞬間に必ず新しいメモリ確保（コピー）が発生し、元の配列を守ることができます。

###### わかりやすい事例：通常のスライス vs フルスライス
**【危険な例】通常のスライス** 「余力（キャパシティ）」が残っているため、`append` すると元の配列の後ろを上書きします。

```go

// 通常のスライス
func main() {
    // 元のデータ（長さ3, 容量3）
    original := []int{1, 2, 3}
    
    // original[0]〜original[1] を切り出す
    // slice は len=2, cap=3 (元のcapを引き継ぐため1つ余力がある)
    slice := original[0:2] 
    
    // slice にデータを追加
    // 余力があるので、元の配列のメモリを使って上書きする！
    slice = append(slice, 99)

    // 結果：元の配列が壊れる
    // original は [1, 2, 99] になってしまう！
}

// フルスライス
func main() {
    original := []int{1, 2, 3}
    
    // 3つ目の数字でキャパシティを制限する
    // len = 2 - 0 = 2
    // cap = 2 - 0 = 2 (余力なし！)
    slice := original[0:2:2] 
    
    // slice にデータを追加
    // 余力がないため、Goは新しいメモリを確保してそこにコピーする
    slice = append(slice, 99)

    // 結果：元の配列は守られる
    // original は [1, 2, 3] のまま
    // slice は [1, 2, 99] （別の場所にある）
}

```

#### ==copy==
オリジナルとはメモリを共有しないスライスを生成する場合、makeとcopyを使用
`copy` は、コピー先 (`dst`) とコピー元 (`src`) のうち、**「長さ (`len`) が短い方」に合わせてコピーします。 スライスが自動的に伸びたりはしません**。
`func copy(dst, src []Type) int`
- **dst (destination):** コピー先のスライス
- **src (source):** コピー元のスライス
- **戻り値:** コピーされた要素の数

```go
x := []string{"a", "b", "c", "d"}
y := make([]string, 4) // 長さ4のスライスを生成　2をしたら二つ分だけ
s := copy(y, x) // yにxをコピー
fmt.Println(x) // [a b c d]
fmt.Println(y) // [a b c d]
fmt.Println(s) // 4

z := make([]string, 2)
copy(z, x[2:]) // xの先頭2要素をzにコピー
fmt.Println(z) // [c d]

// オーバーラップするスライスのコピー
x := []int{1, 2, 3, 4}
fmt.Println(x[:3]) // [1 2 3]
fmt.Println(x[1:]) // [2 3 4]
num := copy(x[:3], x[1:])
fmt.Println(x) // [2 3 4 4]
fmt.Println(num) // 3

// 配列をcopyのソースとターゲットに指定
x := []int{1, 2, 3, 4}
d := [4]int{5, 6, 7, 8}
y := make([]int, 2) // 長さ2のスライスを生成
copy(y, d[:]) // yにdの先頭2要素をコピー
fmt.Println(y) // [5 6]
copy(d[:], x) // yにxをコピー
fmt.Println(d) // [1 2 3 4]
```

##### 配列 <-> スライス変換
```go

// 配列全体->スライス
xArray := [4]int{5,6,7,8}
xSlice := xArray[:]
// 一部の変換
y := xArray[:2]


// スライス全体->配列
xSlice := []int{1,2,3,4}
xArray := [4]int(xSlice)
// 一部の変換
xArray := [2]int(xSlice)

```

##### 文字列
文字列から文字や文字列をインデックス式を使用またはスライスを使用して抽出
```go
var s string = "Hello World" // 変数宣言
//              01234567890
fmt.Println(s[1:]) // ello World
fmt.Println(s[:5]) // Hello
fmt.Println(s[0:5]) // Hello

// 長さ
len(s)
```

#### ==マップ==
Go言語の **マップ (`map`)** は、他の言語でいう「連想配列」「ハッシュマップ」「辞書（Dictionary）」にあたるデータ構造です。 **キー（Key）** と **値（Value）** をペアで保存します。
`map[キーの型]値の型`

```go
var nilMap map[string]int // string -> int 初期値nil

// nilにすると代入でパニックになるので マップリテラルを使用
totalWins := map[string]int{} // nilはfalseになる
totalWins["a"] = 1
```

###### マップリテラル
「キー：値」の形式
キーと値のペアは「,」で区切る
```go
// マップリテラルを使って変数を宣言します
teams := map[string][]string{
	"team1": {"a", "b", "c"},
	"team2": {"d", "e", "f"},
}
```

`make(map[string]int, 10)`
マップは以下のような特徴がある
- 新たな「キーと値のペア」を指定することで大きくなる
- 関数lenを使って個数がわかる
- あらかじめ要素の個数がわかっている場合はmakeを使ってサイズを指定して生成できる
- ゼロ値はnilである
- マップの比較はできない

###### マップの読み書き
```go
totalWins := map[string]int{}
totalWins["h"] = 1
totalWins["w"] = 2
totalWins["l"] = 3
totalWins["l"]++
fmt.Println(totalWins) // map[h:1 l:4 w:2]
```


###### カンマ ok イディオム
カンマ ok イディオムを使用して「ゼロ値と結び付けられているキー」と「マップに存在しないキー」を区別可能
```go
m := map[string]int{
	"a": 1,
	"b": 2,
	"c": 0,
}
v, ok := m["a"]
println(v, ok) // 1 true

v, ok = m["c"]
println(v, ok) // 0 true

v, ok = m["d"]
println(v, ok) // 0 false
```

###### マップからの削除
delete関数を使用
```go
m := map[string]int{
	"hello" : 5,
	"world" : 10
}
delete(m, "hello")
```

###### マップの比較
Go 1.21からmapsというパッケージが標準ライブラリーに追加されました。
関数「maps.Equal」「maps.EqualFunc」を使うことで等しいかどうかの比較可能
`maps.Equal(m,n)`

#### ==構造体==
「関連するデータをまとめる」という用途は、マップより構造体が向いている
構造体は変数との型にも使える
```go

type person struct {
	name string
	age int
	pet string
}

var fred person

bob := person{} // 構造体リテラル。全フィールドゼロ値で初期化
fmt.Println(bob) // { 0 }

// フィールドは「.」でアクセス
bob.name = "Bob"
bob.age = 20
bob.pet = "cat"

fmt.Println(bob.name) // Bob
fmt.Println(bob.age) // 20
fmt.Println(bob.pet) // cat

// 順番に代入
julia := person{"Julia", 25, "dog"}
fmt.Println(julia)

// フィールド名を指定して代入（基本こちら）
mary := person{
	name: "Mary",
	age: 30,
	pet: "bird",
}
fmt.Println(mary)
```


##### 無名構造体
```go
var person struct {
  name string
  age  int
  pet  string
}

person.name = "Bob"
person.age = 20
person.pet = "cat"

fmt.Println(person.name)

var person2 = struct {
  name string
  age  int
  pet  string
}{
  name: "Alice",
  age:  30,
  pet:  "dog",
}

fmt.Println(person2.name)
```

##### 構造体の比較
型名が違うと同じ中身でも比較できないが、片方が無名構造体なら比較できる
