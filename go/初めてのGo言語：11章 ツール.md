---
up: "[[初めてのGo言語]]"
related:
tags:
  - golang
aliases:
  - golang
created: 2025-12-30
updated: 2025-12-30
---
### 概要

#### ==Goのツール==
「ソフトウェア工学は、時間の経過と共に対処しなければならないプログラミングである」と言う思想がある

1. 「一貫性とシンプルさ」を重視し、誰が書いても同じ品質・スタイルになることを強制している。
2. `go` コマンド一つで、整形・テスト・ビルド・パッケージ管理まで完結する高い統合性が特徴。
3. `gofmt` による自動整形が、不毛なスタイル論争を排除し、エンジニアをロジックに集中させる。
4. `pprof` や `trace` といった高度な分析ツールが、大規模システムでの数値に基づく最適化を支える。
5. 「高速なコンパイルと実行」を徹底することで、開発のフィードバックループを止めない設計。

### 詳細

#### ==`go run` -短いプログラムの実行==
コンパイルせずとも、スクリプト言語のように簡単に実行可能
裏側の処理
1. `go run` でバイナリファイルがビルドされ一時ディレクトリにおかれる
2. そのファイルを実行する
3. 終了後、そのファイルは削除される

#### ==`go install` サードパーティのインストール==
Goで作成されたプログラムをコンパイル（機械語に翻訳）し、**自分のPCのどこからでも実行できる「コマンド」としてインストールする**ためのコマンドです。

バックエンドエンジニアが開発ツールを導入したり、自作ツールを自分の環境に配備したりする際に欠かせない存在です。

`go install` したツールがどこに行くのかを知っておくことは非常に重要です。
- **場所:** 通常は `~/go/bin` です（Mac/Linuxの場合）。
- **メリット:** このディレクトリに「パス（PATH）」を通しておけば、ターミナルで `ls` や `cd` と同じように、**どのディレクトリにいてもインストールしたツールを呼び出せる**ようになります。

```go
### 外部のツールをインストールする
// 静的解析ツール staticcheck をインストールする場合
go install honnef.co/go/tools/cmd/staticcheck@latest

### 自分の作ったプログラムをインストールする
// 自分で書いたコード（`main` パッケージがある場所）で実行します。
// プロジェクトのルートで実行
go install .
```

###### `go get` との使い分け（Go 1.16以降のルール）
以前は `go get` でツールをインストールしていましたが、現在は明確に役割が分かれています。
- **`go get`**: プロジェクトに必要な **「部品（ライブラリ）」** を追加する。(`go.mod` が更新される)
- **`go install`**: 自分の環境に **「道具（実行コマンド）」** を追加する。(`go.mod` は更新されない)

#### ==`goimports` -- インポートフォーマットの改善==
`goimports` は、Go 言語の標準フォーマットツールである **`gofmt` の機能を拡張した、さらに便利なツール**です。
「コードの見た目を整えるだけでなく、インポート文（import）の並び替えと追加と削除まで自動で行ってくれる道具」

##### コマンドライン
- 「-l」：フォーマットが正しくない場合はコンソール上に表示
- 「-w」：ファイルを直接書き換える
- 「.」：チェックするディレクトリの指定。ファイル指定も可能。「.」だとサブディレクトリ以下も含め全て

```go
// インストール
go install golang.org/x/tools/cmd/goimports@latest

// ファイルを指定して実行
goimports -l -w .
```

###### vscodeに設定を追加
セーブで自動整形
```json
// Goのフォーマットツールにgoimportsを指定
"go.formatTool": "goimports",
// ファイル保存時にフォーマットを実行する（必須）
"editor.formatOnSave": true,
// [go] 言語固有の設定（念のため）
"[go]": {
	"editor.formatOnSave": true,
	"editor.codeActionsOnSave": {
	"source.organizeImports": "explicit"
	}
}
```

| **機能**         | **gofmt** | **goimports** |
| -------------- | --------- | ------------- |
| インデント・スペースの整形  | ✅         | ✅             |
| 未使用インポートの削除    | ❌         | ✅             |
| 不足しているインポートの追加 | ❌         | ✅             |
| インポートの並べ替え     | ❌         | ✅             |

#### ==コード品質のチェック==
リンターツール
`go vet` 
ビルドのプロセスにリンターを組み込みなら「信頼せよ。ただし検証せよ」
誤った指摘をしないようにコメントにリンターへの追記可能

#### ==`staticcheck`== 
「Go言語専用の、非常に賢いコード診断ツール（リンター）」
サードパーティを **一つ** 選択する場合は、これを使う
Goコミュニティで活動している多くの企業によってサポートされている。
150を超えるコード品質チェックを含みながら、ほとんど誤検知しません

###### インストールと実行
```go
go install honnef.co/go/tools/cmd/staticcheck@latest
staticcheck ./...
```

###### VS Codeとの連携（ここが便利！）
VS CodeのGo拡張機能は、デフォルトで診断エンジンとして `staticcheck` を使用するように設定されています。
- **波線で通知**: コードを書いている最中、おかしな箇所に**オレンジや赤の波線**が表示されます。
- **マウスホバー**: 波線の上にマウスを置くと、「SA4006: this value of ... is never used」のように、**エラーコードとその理由**が表示されます。

|**特徴**|**内容**|
|---|---|
|**役割**|高度な静的解析によるバグ・非効率の発見|
|**思想**|「正しく、効率的で、読みやすいGoコード」を強制する|
|**信頼性**|Goコミュニティで事実上の標準ツール（De facto standard）|

##### `revive` 
Go言語のコードをチェックする **「高速で、設定可能なリンター（Linter）」** です。
一言でいうと、**「古くなった標準ツール `golint` の欠点を克服し、現代のGo開発に合わせて作られたスタイルチェッカー」** です。

###### なぜ `revive` が登場したのか？
これまで、Goのスタイルチェックには公式の `golint` が使われてきました。しかし、`golint` には以下の問題がありました。
- **設定ができない:** 「このルールだけは無視したい」といった柔軟な対応ができず、すべてに従う必要があった。
- **非推奨になった:** 公式がメンテナンスを停止し、代わりのツールを使うことが推奨された。
- **速度:** 巨大なプロジェクトでは実行に時間がかかることがあった。
これらの問題を解決するために、**「高速・高機能・柔軟」** を掲げて作られたのが `revive` です

###### `revive` の主な特徴
① 圧倒的な速さ
`golint` よりも高速に動作するように設計されており、大規模なマイクロサービスなどの開発でもストレスなく実行できます。
 ② 自由自在なカスタマイズ
`revive.toml` という設定ファイルを作ることで、「どのルールを有効にするか」「どのファイルを無視するか」を細かく指定できます。
③豊富なルール（70種類以上）
単なるスタイルチェックだけでなく、コードの読みやすさやメンテナンス性を高めるためのルールが多数用意されています。

| **特徴**     | **staticcheck**  | **revive**          |
| ---------- | ---------------- | ------------------- |
| **主な目的**   | **バグや論理ミス**の発見   | **コーディングスタイル**の統一   |
| **チェック内容** | 無限ループ、未使用変数、性能低下 | 変数名の付け方、コメントの有無、複雑度 |
| **厳格さ**    | 非常に厳密（従うべき）      | チームの好みに合わせて調整可能     |

###### 導入と実行
```go
go install github.com/mgechev/revive@latest
revive ./...
```

##### golangci-lintとは
`golangci-lint` は、これまで紹介してきた `staticcheck` や `revive` など、**数十種類以上のリンター（コード診断ツール）を一つにまとめ、高速に実行するための「統合リンターランナー」**です。

現代の Go 開発において、プロジェクトの品質を保つための **「デファクトスタンダード（事実上の標準ツール）」** となっています。

###### 1. なぜ `golangci-lint` が必要なのか？
Go には多くの優秀なリンターがありますが、それらを個別に実行するのは非効率です。
- **手間がかかる:** `staticcheck`, `revive`, `govet`, `errcheck` ...と、一つずつコマンドを叩くのは面倒です。
- **速度の問題:** 各ツールがバラバラにソースコードを解析すると、重複した処理が発生し、時間がかかります。
- **設定の不統一:** ツールごとに設定ファイルの形式が異なり、管理が複雑になります。
これらを一括で解決するのが `golangci-lint` です。

###### `golangci-lint` の 3 つの強み
① 圧倒的な実行スピード
同じ解析結果を複数のリンターで使い回す（並列処理とキャッシュの活用）ため、個別にツールを動かすよりも遥かに高速です。
② 100種類以上のリンターを内蔵
設定一つで、以下のようなツールを自由自在に組み合わせられます。
- **`staticcheck`**: バグ検知
- **`revive`**: スタイルチェック
- **`unused`**: 未使用のコード（定数、変数、型など）の検出
- **`gosec`**: セキュリティ上の脆弱性スキャン
- **`errcheck`**: エラーハンドリングの漏れをチェック
③ 柔軟な設定（`.golangci.yml`）
「どのディレクトリを無視するか」「どのエラーは許容するか」などを、一つの YAML ファイルで一括管理できます。

###### 実行
1. `brew install golangci-lint`
2. `golangci-lint run`

###### 設定ファイル
```YAML
linters:
  enable:
    - staticcheck # バグ検知
    - revive      # スタイル
    - gosec       # セキュリティ
    - unused      # 未使用コード
  disable-all: false

issues:
  exclude-rules:
    - path: _test\.go # テストファイルは一部のルールを適用外にする
      linters:
        - gocyclo
```

#### ==`govulncehck`==
Go 公式チームが提供している **「セキュリティ脆弱性診断ツール」** です。

一言でいうと、**「自分が使っているライブラリに、ハッカーに悪用される可能性がある欠陥（脆弱性）が含まれていないか」** をチェックしてくれる道具です。

これまでも脆弱性をチェックするツールはありましたが、`govulncheck` は他とは一線を画す **「賢さ」** を持っています。「使っているか」まで見てくれる（コールグラフ解析）

###### 使い方
1. インストール
	1. `go install golang.org/x/vuln/cmd/govulncheck@latest`
2. ルートディレクトリで実行
	1. `govulncheck ./...`

#### ==`go:embed`== 
画像、設定ファイル、HTMLなどの外部ファイルを、ビルドした実行ファイル（バイナリ）の中に直接埋め込む機能」

##### `go:embed` が解決する問題
以前のGoでは、プログラムで設定ファイル（`config.yaml`）やHTMLテンプレート（`index.html`）を使いたい場合、実行ファイルとは別にそれらのファイルを用意して、同じサーバーに配置する必要がありました。
- **問題点:**  ファイルを置き忘れるとプログラムが動かない（File Not Found）。
    - 実行ファイルがある場所（パス）を常に気にしなければならない。
    - デプロイ（本番環境への配置）が面倒。
**`go:embed` を使うと:** 外部ファイルが実行ファイルの一部になるため、「そのバイナリ1つをサーバーに置くだけ」ですべてが完結します。

##### なぜバックエンドで重宝されるのか？
###### 単一バイナリによるデプロイの簡素化
Dockerイメージを作る際も、バイナリを1つコピーするだけで済むため、イメージサイズを小さく、管理を楽にできます。
###### 実行時の安全性が高い
ファイルがメモリ上に展開されているため、実行中に誰かが設定ファイルを書き換えたり、削除したりしてシステムが不安定になるリスクがありません。
###### パフォーマンスの向上
ディスクI/O（ハードディスクからファイルを読み出す処理）が発生しないため、高速にデータにアクセスできます。

```go
import (
	_ "embed" // 1. embedパッケージをインポートする
	"fmt"
)

// 2. // と go:embed の間にスペースを入れない
// 3. 変数の直前に書く
// 4. パスを指定する *も使える
//go:embed version.txt
var version string

func main() {
    println(version) // ファイルの中身がそのまま表示される
}
```

#### ==`go generate`==
コードを生成するためのプログラムを、自動的に実行してくれるツール
「自分で書くのは面倒だが、決まりきったパターンなのでプログラムに書かせたい」

##### `protobuf` 
**go generate protobuf** とは、Protocol Buffers（プロトバフ）というデータ定義ファイル（`.proto`）から、**Go言語のソースコードを自動生成するプロセスを `go generate` コマンドで自動化すること**を指します。

バックエンド開発、特に **gRPC** を使ったマイクロサービス間の通信や、効率的なデータ保存を行う際に必須となる手順です。

###### 使い方
1. インストール
	1. `brew install protobuf`
2. Goプラグインインストール
	1. `go install google.golang.org/protobuf/cmd/protoc-gen-go@latest`
3. `.proto` ファイルを用意する
4. `//go:generate` コメントを書く
	1. `go:generate protoc --go_out=. --go_opt=paths=source_relative user.proto`
5. 実行
	1. `go generate ./...`

```proto
syntax = "proto3";
package user;
option go_package = "./user";

message User {
  int32 id = 1;
  string name = 2;
}
```

##### `stringer`
`stringer` は、Goで「整数（int）で定義した定数（いわゆるEnum）に、対応する名前（文字列）を自動で付け付与するツール」です。

###### 使い方
1. インストール
	1. `go install golang.org/x/tools/cmd/stringer@latest`
2. コード作成
3. 実行
	1. `go generate ./...`
```go
// これをいちいち手書きするのは面倒！
func (s Status) String() string {
    switch s {
    case Running: return "Running"
    ...
}

// 1. ここに指示を書く（-type に型名を指定）
//go:generate stringer -type=Status

type Status int

const (
    Running Status = iota
    Stopped
    Error
)

func main() {
    fmt.Println(Running) // これが "Running" になる！
}
```

#### ==`go generate` と `Makefile` の使い分け==
`go generate` ：ソースコードの生成を担当
`Makefile` ：ソースコードの検証および、コンパイル

#### ==`Go` バイナリ内のビルド情報を取得==
```go
# 1. まずバイナリを作成（名前を app に指定）
go build -o app

# 2. そのバイナリに対して -m を実行
go version -m app
```

#### ==クロスコンパイル==

ターミナルで以下の環境変数をセットしながらビルドを行います。
`GOOS=ターゲットOS GOARCH=ターゲットCPU go build -o 出力ファイル名`

GoがサポートしているすべてのOSとアーキテクチャの組み合わせは、以下のコマンドで確認できます。
`go tool dist list`

#### ==ビルドタグ==
Goにおける**ビルドタグ（Build Tags）およびビルド制約（Build Constraints）とは、特定の条件（OS、アーキテクチャ、あるいは自分で定義したフラグ）に合わせて、「どのソースファイルをビルドに含めるか」をコンパイラに指示する仕組み**のことです。

```go
//go:build linux && amd64
// +build linux,amd64  <- 古い形式（Go 1.17未満との互換性のために残すことが多い）

package mypkg
```

> [!info] `//go:build` コメントと `package` 宣言の間には、必ず **1行以上の空行** を入れる必要があります。

##### ビルド制約の論理演算（メタ制約）
ビルド制約では、論理演算子を使って複雑な条件（メタ制約）を記述できます。

| **演算子**    | **意味**    | **例 (//go:build ...)**          |
| ---------- | --------- | ------------------------------- |
| **`&&`**   | AND（かつ）   | `linux && amd64` (Linuxかつ64bit) |
| **`        |           | `**                             |
| **`!`**    | NOT（でない）  | `!windows` (Windows以外)          |
| **`,`**    | OR (旧形式)  | `linux,darwin` (旧形式でのOR)        |
| **(スペース)** | AND (旧形式) | `linux amd64` (旧形式でのAND)        |

#### ==旧バージョンの処理系を使ったテスト==
| **手法**              | **メリット**              | **デメリット**          |
| ------------------- | --------------------- | ------------------ |
| **公式 `go1.x` コマンド** | 手軽、開発中にすぐ試せる          | 自分のPCに実体が増える       |
| **Docker**          | 環境が汚れない、OS環境も固定できる    | 初回のイメージ取得に時間がかかる   |
| **GitHub Actions**  | **自動で全環境チェックできる（必須）** | 設定が必要、結果が出るまで数分かかる |



#### ==`go help`== 
ツールやランタイム環境の詳細を確認可能