---
up: "[[初めてのGo言語]]"
related:
tags:
  - golang
aliases:
  - golang
created: 2025-12-29
updated: 2025-12-29
---
### 概要

パッケージやモジュールを使ったコードの構成方法、「インポート」の方法、サードパーティのライブラリの利用法、そして独自ライブラリの作成方法の解説

### 詳細

#### ==リポジトリ、モジュール、パッケージ==
「大きい方」から、リポジトリ、モジュール、パッケージの3つの概念を使って管理されます

- リポジトリ
	- バージョン管理システム（VSC）が備わっている。モジュールはGoのライブラリあるいはアプリケーションのルート（root）になり、リポジトリに保存される
- モジュールとパッケージ
	- モジュールは、一個または複数のパッケージから構成される。
	- パッケージが最小単位

##### モジュールパス
グローバルでユニークな値で、通常はモジュールのあるリポジトリへのパスを使う
例：「github.com/ユーザー名/リポジトリ名」
- モジュール：Proteus
- Github：https://github.com/hoge/proteus
- モジュールパス：github.com/hoge/proteus

一意でない名前のモジュールをソースコードリポジトリに配置すると、別のモジュールからインポートできない

#### ==モジュールとgo.modファイル==
Goのコードのディレクトリツールは、有効なgo.modがある場合にモジュールになる
<mark style="background: #D2B3FFA6;">大文字・小文字</mark>の区別があるので、小文字に統一

- go.mod作成
`go mod init モジュールパス`

- モジュールパス変更
`go mod edit -module=example.com/newpath`

ディレクティブを使用してモジュールに関する情報を記述

```go
// 一意なパス
module github.com/hoge/proteus


// モジュール内のコードはここに指定されたバージョンと互換性がある
go 1.24.1
```

##### goディレクティブを使ったビルドバージョンの管理
goディレクティブでインストールされたバージョンよりも新しいバージョンを指定した場合は次のように処理される
- Go1.20以前がインストールされている場合
	- 新しいバージョンは無視され、インストールしているバージョンが使用される
- Go1.21以降がインストールされている場合
	- デフォルトの動作では、新しいバージョンGoをダウンロードしてそれを使用する
	- ただし「toolchain」ディレクティブと「GOTOOCHAIN」環境変数で制御可能
		- 両方がある場合は環境変数が優先される
		- auto：新しいバージョンをダウンロード
		- local：1.21より前のGoのリリースの動作を復元
		- go 1.20.4：特定のGoのバージョンで、それが使用される

- ビルド
`GOTTOLCHAIN=gol1.18 go build`

##### `require` ディレクティブ
開発中のディレクティブが依存する他のモジュールと最低限のバージョンを指定

二つの構成になる
- モジュールの直接の依存関係がリストされる
- 自分が利用する（依存する）モジュールがリストされる
	- `//indirect` で依存関係を明示する

他に `replace` `exclude` `retract` のディレクティブがある

#### ==パッケージの構成==
importの利用方法、パッケージの作成と整理の方法
Goのパッケージの長所と短所を見ていきましょう

##### エクスポートする識別子の指定
Import文を使用すると、別のパッケージでエクスポートされた識別子（変数、定数、型、関数、メソッド、および構造体のフィールドの名前）にアクセス可能になる
Goの識別子のエクスポートは「キャピタライズ（先頭大文字）」にすることで、外部参照可能か決まる。
識別子をエクスポートする際は、クライアントに公開されることを考慮しておく必要がある
エクスポートされるものは全て、ドキュメントに記載し、メジャーバージョンを上げる場合を除き、後方互換性を意識する

##### パッケージの作成とアクセス
- **パッケージ宣言**
	- パッケージに書いた識別子がそのパッケージの名称になる
- **インポートパス**
	- プロジェクト内のパッケージを参照
	- インポートパスは2種類ある
		- 「モジュールパス」
			- `github.com/hoge/sample`
		- 「モジュール内のパッケージパス」
			- `math`
```go

// sample/math.go
package math

func Double(a int) int {
	return int * 2
}

// samle/main.go
package main

// インポートパス

// 標準ライブラリの math と区別するためにエイリアスをつける
import myMath "github.com/hoge/sample/math"

func main() {
	myMath.Double(2)
}
```

##### ==パッケージ名とインポートパス==

##### 命名法
- 提供する機能を説明するパッケージ名にする
	- 基本は名詞で、変換系は動詞
- 全て小文字
- 短く簡潔に、
- 特殊なフォルダ名
	- **`internal/`**: この中にあるパッケージは、**同じプロジェクト内からしかインポートできません。** 外部（公開ライブラリとして他の人）に使わせたくないコードはここに入れます。
	- **`pkg/`**: 以前の慣習で「外部公開用」として使われていましたが、現在のモダンなGoでは**非推奨**（ルートに置くのが推奨）とされることが多いです。
	- **`cmd/`**: 実行ファイル（`main` パッケージ）を置く場所です。
		- `cmd/myapp/main.go` のように配置します。
##### ルール
- パッケージ名とディレクトリ名を一致させるのがお作法
	- 「1ディレクトリ＝1パッケージ」の原則
- mainはGoの開始点で、mainはインポートできない

##### エイリアス
名前が衝突する際は別名をつける
```go

import (
	crand "crypto/rand"
	"math/rand"
)
```


##### Go Doc
Goには自動的にドキュメントに変換されるコメントを書くための方法 `Go Doc` が用意されています

- ドキュメント化する項目の直前にコメントを配置し、コメントの項目の宣言の間に空白行を入れない
- コメントの各行は、 `//` で開始し、その後にスペースも一つ入れる
- コメントの最初のシンボル（関数、型、定数、変数、またはメソッド）の名前にする
- コメントを複数の段落に分割するには、空のコメント行を使う

HTML形式で出力可能で上記以外にも見栄えを良くするやり方がある

```go
// Package calc は、基本的な計算機能を提供するためのパッケージです。
// このようにパッケージ宣言の直前にコメントを書くと、パッケージ全体の解説になります。
package calc

import "fmt"

// Calculator は、計算機の状態を保持する構造体です。
// 構造体名の直前にコメントを書きます。
type Calculator struct {
	// Name は計算機の名前です。
	Name string
}

// Add は、2つの整数を足し算した結果を返します。
// 関数名で始まる文章にすると、go doc で表示された時に読みやすくなります。
func (c *Calculator) Add(a, b int) int {
	return a + b
}

// ShowResult は、計算結果をフォーマットして標準出力に表示します。
func (c *Calculator) ShowResult(result int) {
	fmt.Printf("[%s] 計算結果: %d\n", c.Name, result)
}
```

###### ブラウザで確認する場合
最近の Go では `go doc` (CLI) のほかに、ブラウザで綺麗に閲覧できる **`pkgsite`** というツールが推奨されています。
```go
// インストール
go install golang.org/x/pkgsite/cmd/pkgsite@latest

// 実行（プロジェクトのルートで）
pkgsite -http=:8080
```

##### internalパッケージの利用
「外部からのインポートを禁止する、プライベートなパッケージ」で外部クライアントの使用を制限する
```Plaintext
myproject/
├── go.mod
├── app/
│   └── main.go       <-- (A) インポート可能
├── internal/
│   └── secret/
│       └── logic.go  <-- package secret
└── pkg/
    └── public.go     <-- (B) インポート可能
```

###### なぜ `internal` を使うのか？
主な理由は「**ライブラリの保守性を高めるため**」です。
- **APIを汚さない:** 外部のユーザーに公開したい機能（パブリックAPI）だけを見せ、内部的な計算ロジックなどは隠すことができます。
- **破壊的変更がしやすい:** 外部の誰も使っていないことが保証されるため、自分のプロジェクト内で自由にリファクタリング（コードの書き換え）ができます。
- **依存関係の整理:** 「このコードは外から使われることを想定していない」という意図を明確に示せます。

##### 循環参照
Go言語には「高速なコンパイル」と「ソースコードの理解の容易さ」という二つの大きな目標があります。
この実現ためには、パッケージ間の「循環参照」は許されない。
片方が、インポートしている場合。もう片方にインポートは不可

##### モジュールの構成方法
構成の正式なルールはないが、パターンはある
コードが「理解しやすく保守しやすいものになるように」という原則がある

モジュールは大きく2種類に別れる
###### 単独のアプリケーションの場合
- プロジェクトのルートはmainパッケージにする
	- mainパッケージのコードは最小限にする
- ビジネスロジックはinternalディレクトリに置く
	- mainから参照する
	- これでアプリケーションの実装に依存するようなモジュールを誰も作成できないようにする
- 規模が大きくなると、機能ごとにパッケージとしてまとめるようにする

##### ライブラリの場合
- モジュールのルートにリポジトリ名と一致するパッケージ名が必要
	- インポート名 = パッケージ名
- ユーティリティととして複数のアプリケーションが含まれていることは珍しくないので、この場合にルートにcmdディレクトリを作成
	- バイナリごとに各ディレクトリを作成（各ディレクトリにはパッケージ名としてmainを使う
- internalパッケージを活用する
	- モジュール内に複数のパッケージを作成して、internalの外におき、シンボルをエクスポートしてモジュール内の別のパッケージで使えるようにすると、誰もが使えるようになる

##### ハイラムの法則
「APIのユーザーが十分に多ければ、そのAPIが（ドキュメントなどで）何を約束しているかは関係ない。そのシステムが持つあらゆる『観測可能な挙動』は、遅かれ早かれ誰かの依存対象になる」

###### なぜこの法則が「恐ろしい」のか？
あなたが「これはバグだから修正しよう」とか「効率化のために内部ロジックを少し変えよう」と思ったとしても、**誰かがその「バグっぽい挙動」や「特定の処理速度」に依存してコードを書いている**場合、あなたの修正はその誰かのシステムを破壊してしまいます。

###### Goの `internal` はこの法則への「唯一の対抗手段」
ハイラムの法則がある以上、**「公開してしまったら最後、勝手に変えることはできない」**と考えるのがプロの設計です。
Goの `internal` パッケージは、この「観測可能な範囲」を強制的に制限します。
1. **観測を遮断する:** `internal` に入れたコードは、外部からはインポートすらできないため、物理的に依存される可能性をゼロにします。
2. **責任の範囲を限定する:** 「ここから先（Public）の挙動には責任を持ちますが、あちら（Internal）の挙動は明日変わるかもしれませんよ」という境界線を、コンパイルレベルで引くことができます。

「ハイラムの法則」を知っているエンジニアは、パッケージを設計する際にこう自問自答します。

> **「この関数（またはフィールド）を公開することで、自分は一生その『今の挙動』を維持する覚悟があるか？」**

もし「NO（将来変えるかもしれない）」であれば、迷わず `internal` パッケージへ放り込むのが正解です。

##### APIの名称変更や再構成
後方互換性を保つために、削除するのは避け、別名「型エイリアス」を提供するのが良いでしょう

パッケージ名そのものを変えたい場合（エイリアス・インポート）
パッケージ名を `math` から `fastmath` に変えたいなど、ディレクトリ構造レベルで変更したい場合は、「転送用パッケージ」を作ります。

###### エクスポートされた識別子で別名をもてない2種類のもの
- パッケージレベルの変数は別名をもてない
- 構造体のフィールドも同様

```go
package calc

// Engine は新しい名前の構造体です（こちらが本体）。
type Engine struct {
    Name string
}

// Calculator は古い名前です。
// 「=」を使うことで、Engine と全く同一のもの（エイリアス）として扱われます。
type Calculator = Engine // これが型エイリアス

// NewEngine は新しい推奨されるコンストラクタです。
func NewEngine() *Engine {
    return &Engine{}
}
```

| **ステップ**   | **アクション**                | **目的**              |
| ---------- | ------------------------ | ------------------- |
| **1. 作成**  | 新しい名前で構造体や関数を作る          | 本体の定義               |
| **2. 橋渡し** | 型エイリアス（`=`）やラッパーを作る      | 互換性の維持（既存ユーザーを壊さない） |
| **3. 通告**  | `// Deprecated:` コメントを追加 | 移行の促進               |

##### init関数
「プログラムが動き出す前の準備」を司る非常に重要な仕組みで、主に「グローバルな状態の初期化」や「環境チェック」に使われます。
またパッケージレベルのイミュータブルな変数を扱う

`init`関数は、パッケージが読み込まれた時に**自動的に実行される特殊な関数**です。
###### 主な特徴
- **自動実行:** `main`関数よりも先に実行されます。
- **引数・戻り値なし:** `func init() { ... }` という形式のみ許されます。
- **呼び出し不可:** コードから明示的に `init()` を呼び出すことはできません。
- **複数定義可能:** 1つのパッケージ（あるいは1つのファイル）内に複数の `init` を書くことができ、書いた順に実行されます。

###### 実行順番
Goプログラムが起動すると、以下の図のような順序で処理が進みます。
1. **インポートされたパッケージ**がまず初期化される（再帰的）。
2. パッケージ内の**定数と変数**が初期化される。
3. **`init`関数**が実行される。
4. 最後に `main.go` の **`main`関数**が実行される。

```go
package main

import "fmt"

var config string

func init() {
    // プログラム開始前に変数を設定したり、DB接続確認をしたりする
    config = "読み込み完了"
    fmt.Println("init: 準備が整いました")
}

func main() {
    fmt.Println("main: 実行開始！ config =", config)
}
```


###### ブランクインポート (`_`) とは？
通常、Goではインポートしたパッケージを使わないとコンパイルエラーになります。しかし、「パッケージ内の関数は使わないけれど、`init`関数だけは実行させたい」という場合に使うのがブランクインポートです。

```go
import _ "github.com/lib/pq" // パッケージ名の前にアンダースコアを入れる
```

###### ドキュメント
暗黙のうちに関数が呼び出されるので、ドキュメントにその振る舞いを書いておこう


#### ==モジュール関連の操作==
他のモジュールやモジュール内のパッケージと統合する方法とは

##### サードパーティのコードのインポート
初期化と依存関係のコマンドを打つ
- 「go.md」「go.sum」のファイルができる
- `go.mod` に記述がない依存関係がある場合、`go run` などのコマンドを実行したタイミングで Go が自動的にダウンロードし、キャッシュ（保存）し、さらに `go.mod` を更新しようとします
```go
go mod init github.com/learning-book-2e/money
go mod tidy
```

###### `go.sum` について
`go.mod` が「どのライブラリのどのバージョンが必要か」を記した「注文書」だとすれば、`go.sum` はそのライブラリが本物であることを証明する「受領印付きの証明書（チェックサム）」です。

###### セキュリティ
- **改ざん防止（セキュリティ）:** もし悪意のある第三者が、GitHub 上にある既存のタグ（例：v1.4.0）の内容をこっそり書き換えたとしても、Go は `go.sum` のハッシュ値と比較して不一致を検知し、ビルドを停止させます。
- **再現性の確保:** チームの他のメンバーや CI/CD 環境でビルドする際、全員が**「1 ビットの狂いもなく全く同じソースコード」**を使っていることを保証します
###### `go.sum` の更新の仕方
- モジュールとそのバージョン、モジュールのチェックサム
- そのモジュールの `go.mod` ファイルのチェックサム 

##### モジュールのバージョン
`go list` は、Goのプロジェクトが「今どういう状態か」「どんなライブラリに依存しているか」を覗き見るための、非常に強力な「調査・診断用コマンド」です。

バックエンド開発では、ライブラリのバージョンアップ時や、依存関係の競合を解決するときに頻繁に使います。

###### `go list` の基本（パッケージを診る）
引数なしで実行すると、「カレントディレクトリにあるパッケージ名」を表示します。
- **`go list ./...`**: カレントディレクトリ以下の**すべてのパッケージ**をリストアップします。
- **`go list -json`**: パッケージの情報を詳細なJSON形式で出力します。ソースコードの場所や、インポートしている他のパッケージ一覧などがわかります。

###### `go list -m`（モジュールを診る）
`-m` フラグをつけると、対象が「パッケージ（個別のフォルダ）」から **「モジュール（`go.mod` 単位）」** に切り替わります。
- **`go list -m all`**: 現在プロジェクトが依存している**すべてのモジュールと、そのバージョン**を一覧表示します。
- **`go list -m -u all`**: 現在使っているライブラリに **「新しいバージョン（Update）」** が出ているかどうかを確認できます。 （最新版がある場合は、現在のバージョンの横に `[v1.5.0]` のように表示されます）

実行結果の例
```go
my-project (自プロジェクト)
github.com/shopspring/decimal v1.4.0
github.com/fatih/color v1.15.0
```

###### `go list -m -versions`（利用可能な全バージョンを診る）
これが最も便利な使い方の一つです。あるライブラリが **「過去から現在まで、どんなバージョンを公開しているか」** をインターネット（Go Proxy）に問い合わせて表示します。
**なぜこれを使うのか？**
- **ダウングレードしたい時:** 最新版にバグがあった際、一つ前の安定版が何だったかを確認するために使います。
- **脆弱性対応:** セキュリティ修正が入った特定のバージョンが存在するか確認する際に役立ちます。

```go
go list -m -versions [モジュール名]
```

###### 実行場所の注意点（前回の復習）
`go list`（パッケージモード）と `go list -m`（モジュールモード）では、実行場所による挙動が異なります。

|**コマンド**|**実行場所**|**挙動**|
|---|---|---|
|**`go list`**|`.go` ファイルがある場所|そのフォルダのパッケージ名を表示。|
|**`go list -m`**|`go.mod` がある場所（ルート）|`go.mod` に基づいた情報を表示。|

###### `go get`
`go get` は、自分のプロジェクトに**外部ライブラリ（サードパーティ・パッケージ）を追加・更新・削除するためのコマンド**です。

他の言語でいう `npm install` (Node.js) や `pip install` (Python) に近い役割ですが、Go特有のルールがあります。

| **コマンド**                  | **意味**                         |
| ------------------------- | ------------------------------ |
| **`go get [URL]`**        | 最新版（通常は最新のタグ、なければ最新コミット）を取得    |
| **`go get [URL]@v1.2.3`** | **特定のバージョン**を指定して取得            |
| **`go get [URL]@master`** | masterブランチの最新状態を取得             |
| **`go get -u [URL]`**     | すでに導入済みのライブラリを**マイナーアップデート**する |
| **`go get [URL]@none`**   | そのライブラリをプロジェクトから**削除**する       |


#### ==ミニマルバージョン選択==
複数のモジュールが、一つのモジュールに依存している場合に、依存するバージョンがそれぞれ異なる場合、「全てのgo.modファイルの条件を満たす最低のバージョン」を使うことを<mark style="background: #D2B3FFA6;">ミニマルバージョン選択の原則</mark>と言う

###### import互換性ルール
新しいパッケージが古いパッケージと同じインポートパスを持つ場合、新しいパッケージは古いパッケージに対して後方互換性（Backward Compatibility）を維持しなければならない
なので作成者に連絡する

##### 互換性を持つバージョンへのアップデート
「現在のマイナーバージョンを維持したまま、バグ修正（パッチ）だけを最新にする」
`go get -u=patch モジュールパス` 

###### セマンティックバージョニング（SemVer）
このコマンドを理解するには、バージョンの数字の意味を知る必要があります。
例：`v1.4.2`  `v[メジャー].[マイナー].[パッチ]` 
- 1：メジャー
	- 破壊的変更（互換性なし）
- 4：マイナー
	- 機能追加（後方互換性あり）
- 2：パッチ
	- バグ修正のみ（後方互換性あり）

##### 非互換性のバージョンへのアップデート（セマンティック・インポートバージョニング）
Goのモジュールシステムにおいて、「メジャーバージョンを上げるなら、インポートパス（URLのような名前）自体も変えなければならない」というルールのこと

###### なぜこれが必要なのか？（ダイヤモンド依存問題の解決）
バックエンド開発で最も恐ろしいのは、「同じライブラリの異なるバージョンを同時に使いたい」という状況です。これをダイヤモンド依存問題と呼びます。
**具体的なシナリオ**
1. あなたのアプリは **ライブラリA** と **ライブラリB** を使っている。
2. **ライブラリA** は、ある便利ツールの **v1.0.0** を使っている。
3. **ライブラリB** は、その便利ツールの **v2.0.0（破壊的変更あり）** を使っている。

もし、どちらも `import "github.com/user/tool"` という同じ名前（インポートパス）を使っていたら、Goはどちらを使えばいいか分からず、ビルドが壊れてしまいます。

###### SIVによる解決策：パスを変える
Goはこの問題を、「メジャーバージョン2以降は、パスの末尾に /v2, /v3... を付ける」というルールで解決しました。

|**バージョン**|**インポートパス（例）**|**扱い**|
|---|---|---|
|**v0.x.x / v1.x.x**|`github.com/user/lib`|デフォルト（サフィックスなし）|
|**v2.x.x**|`github.com/user/lib/v2`|**全く別のパッケージ**として扱う|
|**v3.x.x**|`github.com/user/lib/v3`|**全く別のパッケージ**として扱う|

##### ベンダリング
「プロジェクトが依存している外部ライブラリのソースコードを、自分のプロジェクト内にコピーして管理すること」

###### Goでのやり方：`go mod vendor`
Goモジュールを使っている場合、コマンド一つで実行できます。
1. **コマンド実行:** `go mod vendor` を叩く。
2. **結果:** プロジェクトルートに `vendor/` フォルダが生成され、`go.mod` に記載されたライブラリのソースコードがすべてコピーされます。
3. **ビルド時:** `go build -mod=vendor` と指定すると、インターネットやキャッシュを見に行かず、`vendor/` フォルダ内のコードだけを使ってビルドします。

###### なぜベンダリングをするのか？（メリット）
「`go.mod` があるから自動でダウンロードしてくれるのに、なぜわざわざコピーを持つの？」という疑問が湧くかもしれません。これには**「バックエンドの堅牢性」**に関わる重要な理由があります。
- **ビルドの再現性が100%になる:** インターネットが繋がらない環境や、GitHubからライブラリが削除されてしまった場合でも、手元にコードがあるため確実にビルドできます（「レフトパッド問題」のような事故を防げます）。
- **ビルド速度の向上:** CI/CD（自動ビルド）環境で、毎回数千のパッケージをダウンロードする時間を節約できます。
- **コードの監査（セキュリティ）:** 外部ライブラリに悪意のあるコードが含まれていないか、自分のGit管理下に入れてコードレビューの対象にできます。

###### ベンダリングとモジュールキャッシュの比較

| **項目**      | **モジュールキャッシュ（通常）** | **ベンダリング**              |
| ----------- | ------------------ | ----------------------- |
| **コードの場所**  | ユーザーディレクトリの奥深く     | **プロジェクト内の `vendor/`**  |
| **インターネット** | 初回は必須              | **不要（オフラインOK）**         |
| **Git管理**   | 含めない               | **含める**                 |
| **主な用途**    | 個人開発、一般的な開発        | **エンタープライズ、厳格なCI、モノレポ** |