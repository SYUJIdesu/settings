---
up: "[[初めてのGo言語]]"
related:
tags:
  - golang
aliases:
  - golang
created: 2025-12-23
updated: 2025-12-23
---
### 概要

Goのインターフェースは、他の言語（JavaやC#など）のインターフェースとは似て非なる、**Go言語において最も強力でユニークな機能**の一つです。
多言語と違うのは「**暗黙的**」に行われることです

Goのインターフェースは、「型の安全性」と「デカップリング（分離）」の両方が達成され、静的言語と動的言語の両方を持ち合わせている？
GoF本では「インターフェースに従って、プログラムしろ実装ではなく」

一言でいうと、インターフェースとは「型がどのような振る舞い（メソッド）を持つべきか」という「契約（コントラクト）」です。
**Goで唯一の抽象型である**

命名規則として「〜するもの」「〜する人」を表す「er」で終わる名前が多い。

```go
type Speaker interface {　//インターフェースの宣言。インターフェース型の一種
    Speak() string //実装するメソッドのリスト（メソッドリスト）

### 実装（構造体側）
`implements` などのキーワードは一切使いません。ただメソッドを定義するだけです。
type Dog struct{}
func (d Dog) Speak() string { return "Woof!" }

type Cat struct{}
func (c Cat) Speak() string { return "Meow!" }

```

- **インターフェースリテラル**
	- `interface` に続いて `{}`に囲まれたメソッドのリストが書かれます

- **メソッドセット**
	- インターフェースで定義されたメソッドの集まり

- デコレータパターンを使ってインタフェースの実装をラップする
### 詳細

#### ==インタフェースは堅安全なダックタイピング==
ダックタイピングとは、プログラミングにおける型付けの考え方の一つ

「そのオブジェクトが何であるか（名前や継承関係）」よりも、「そのオブジェクトで何ができるか（振る舞い）」を重視するスタイルです。
Goはどちらも兼ね備える言語

```go
package main

import "fmt"

// LogicProvider は Logic インターフェースを実装する構造体です。
type LogicProvider struct{}

// Process はデータを処理するメソッドです。
func (l LogicProvider) Process(data string) string {
	// ビジネスロジック
	return data
}

// Logic はデータを処理するインターフェースです。
type Logic interface {
	Process(data string) string
}

// Client は Logic を使用するクライアントです。
type Client struct {
	L Logic
}

// Program はクライアントが Logic を使用してプログラムを実行するメソッドです。
func (c Client) Program() string {
	return c.L.Process("Hello, World!")
}

// main はプログラムのエントリポイントです。
func main() {
	c := Client{L: LogicProvider{}}
	hello := c.Program()
	fmt.Println(hello)
}
```

#### ==埋め込みとインタフェース==
インタフェースにインタフェースを埋め込み可能
```go
type Closer interface {
	Close() error
}

type ReadCloser interface {
	Closer // インターフェースを埋め込む
}
```

#### ==インタフェースを受け取り、構造体を返す==
「<mark style="background: #D2B3FFA6;">インタフェースを受け取り、構造体を返せ</mark>」というアドバイスがを聞くことになる。
具体的に言うと、「<mark style="background: #D2B3FFA6;">関数内で処理されるビジネスロジックは、インタフェースを介して起動されるべきであるのに対して、関数の出力は型であるべき</mark>」

#### ==インタフェースとnil==
nilは抽象型であるインタフェースのインスタンスのゼロ値であるが、具象型ほど単純な話ではない。
型フィールドが非nilである限り、インタフェースも非nilになる

#### ==インタフェースは比較可能==
Goにおけるインターフェースの比較は、一見シンプルですが、内部構造（**動的な型**と**動的な値**）を理解していないとバグやパニックの原因になりやすい、非常に奥が深いトピックです。

##### 1. インターフェースが「等しい」と判定される条件
2つのインターフェース値を比較したとき、以下の**両方**を満たす場合にのみ `true` となります。
1. **動的な型（Type）** が一致している。
2. **動的な値（Value）** が一致している。

> [!NOTE] どちらも `nil`（型も値も未設定）である場合も、等しいと判定されます。

```go
var a, b interface{}

a = 10 // 型: int, 値: 10
b = 10 // 型: int, 値: 10
fmt.Println(a == b) // true

b = int64(10) // 型: int64, 値: 10
fmt.Println(a == b) // false（型が違うため）
```

##### 2. nil との比較（最大の罠：Typed Nil）
Goのインターフェース比較で最も有名な罠が、**「型情報を持った nil」** です。インターフェースが `nil` と判定されるのは、**「型」も「値」も両方が `nil` のときだけ**です

- `s` は単なるポインタなので `nil` です。
- `i` はインターフェースなので、内部に **「型：_string」_* という情報を持ってしまっています。
- そのため、`i` は「値は nil だけど、型情報があるから完全な nil ではない」と判断されます。
```go
func main() {
    var s *string = nil
    var i interface{} = s // i に nilポインタを代入

    fmt.Println(s == nil) // true
    fmt.Println(i == nil) // false ！！
}
```

##### 3. 比較できない型（パニックの危険性）
インターフェースに格納されている「動的な値」が **比較不可能な型**（スライス、マップ、関数など）である場合、比較を行った瞬間に **ランタイムパニック** が発生します。
これを防ぐには、リフレクション（`reflect.DeepEqual`）を使うか、あらかじめ型をチェックする必要があります。
```go
var a, b interface{}

a = []int{1, 2}
b = []int{1, 2}

// fmt.Println(a == b) // ここでパニック！ (panic: runtime error: comparing uncomparable type []int)
```

|**比較対象 A**|**比較対象 B**|**結果**|
|---|---|---|
|`nil` インターフェース|`nil` インターフェース|`true`|
|`nil` インターフェース|値が入ったインターフェース|`false`|
|型が異なるインターフェース|（任意）|`false`|
|型が同じインターフェース|値が等しい|`true`|
|型が同じインターフェース|値が異なる|`false`|
|**比較不能な型**を含む|**比較不能な型**を含む|**パニック**|

#### ==空インタフェース==
Goの**空インターフェース（`interface{}`）**、およびGo 1.18から導入されたその別名である`any`について、その仕組みと使い方を簡潔にまとめました。

##### 1. 空インターフェースとは何か？
一言でいうと、「どんな型でも代入できる魔法の箱」です。

Goのインターフェースは「指定されたメソッドをすべて持っていれば、その型とみなす」というルールです。空インターフェースは「必要なメソッドが0個」なので、結果としてすべての型がこの条件を満たしてしまいます。
```go
var x any // または var x interface{}

x = 42          // int
x = "hello"     // string
x = struct{}{}  // 構造体
```

##### 2.内部構造：中身はどうなっている？
空インターフェースは、内部的に **`eface`** と呼ばれる構造体で管理されています。単なる「データ」ではなく、「型情報」と「データ本体へのポインタ」のペアを保持しています。
- **Typeポインタ**: 入っているデータの本来の型（`int`や`string`など）を指す。
- **Dataポインタ**: 実際のデータが保存されているメモリのアドレスを指す。
この構造があるおかげで、後から「中身が何型だったか」を判定できるのです。

##### 3. 中身を取り出す方法
`any` に入れた値は、そのままでは元の型の機能（計算や文字列操作など）を使えません。「型アサーション」や「型スイッチ」を使って元の型に戻す必要があります。

##### 4. 空インターフェース vs ジェネリクス
Go 1.18でジェネリクス（`T` など）が登場したことで、空インターフェースの使いどころは変わりました。

| **特徴**   | **空インターフェース (any)** | **ジェネリクス (T)**         |
| -------- | ------------------- | ---------------------- |
| **判定時期** | **実行時**に型をチェックする    | **コンパイル時**に型が決まる       |
| **安全性**  | 間違った型を扱うとパニックの危険    | 型が保証されるため安全            |
| **性能**   | 型の変換コスト（オーバーヘッド）がある | 変換が不要なため高速             |
| **用途**   | 型が本当にバラバラなデータを扱う時   | 特定の型に縛られず、共通ロジックを書きたい時 |

##### 5. 設計のアドバイス：いつ使うべき？

> [!error] **「便利だから」という理由で `any` を多用するのは避けましょう。** Goの強みである「静的型付け（コンパイル時にミスに気付く）」が失われてしまいます。

- **使うべき時**：`fmt.Println` のように、本当にどんな型が来るか予測できない汎用ライブラリを作る時。
- **避けるべき時**：関数の引数など。可能な限り具体的なインターフェースやジェネリクス、または具体的な構造体を使うのが「Goらしい」安全な設計です。
- **リフレクションの活用**：anyを引数に取る関数は、値を記憶したり読んだりするのにリフレクションを使うことが多い


#### ==型アサーションと型Switch==
インタフェース型の変数が特定の具象型を持っているか、あるいはその具象型が別のインタフェースを実装しているかを調べるのに、Goには二つの方法があります。

##### ==型アサーション==
そのインタフェースを実装する具象型の名前を指定します。（あるいはそのインタフェースの基底型となっている具象型によって実装されている別のインタフェースの名前を指定します）

「このインターフェースの中身は、実は 〇〇型だよね？」と確認して取り出すのが型アサーションです。
```go
 変数 := インタフェース変数.(具体的な型)
 
 var i any = "Hello"

// i を string として取り出す
s := i.(string)
fmt.Println(s + " World") // string型として扱える
 
```

###### 1. カンマ ok イディオム
型アサーションには大きなリスクがあります。もし予想と違う型を指定してしまうと、プログラムがその場でパニック（強制終了）してしまいます。
これを防ぐための安全な書き方が、**カンマ ok イディオム**です。

- **`value`**: 成功すればその型の値、失敗すればその型の初期値（ゼロ値）が入る。
- **`ok`**: 成功すれば `true`、失敗すれば `false` が入る。
```go
value, ok := i.(string)
if !ok {

}
```

##### ==型Switch==
インタフェースが複数の型のいずれかである可能性がある場合に使用。
インタフェース以外（ `any` を含む ）が使うとコンパイルエラーになる
**「変数の型がケースごとに確定する」**

インターフェース型の変数に「今、具体的に何型が入っているか」を判定し、その型に応じて処理を分岐させるためのGo言語の構文です。
###### 1. 変数 `v` がその型として使える
`switch v := i.(type)` と書くと、各 `case` の中では、変数 `v` は**すでにその型にキャスト（アサーション）された状態**になります。
- `case int:` の中では、`v` は最初から `int` 型として振る舞います。
- わざわざ `v.(int)` と書き直す必要はありません。

##### 2. nil も安全に判定できる
`case nil:` を作ることで、インターフェースの中身が空である状態をスマートに処理できます。

##### 3. 複数の型をまとめることもできる
通常のスイッチ文と同様に、カンマ区切りで複数の型を指定できます。ただし、この場合は `v` の型が特定できないため、`v` は元のインターフェース型のままとなります。
`case int, int64 // この場合は特定の型に確定しない(any)`

```go
switch j := i.(type) {
	case nil: // iはnil。jの型はany
		fmt.Printif()
	case int:   // j：int
	case Myint: // j：Myint
	case bool, rune: // iはboolかruneなので j：any
	default: // iの型は不明 jの型はany
}
```

#### ==型アサーションと型swtichの利用は控えめに==
基本それ以外の型が使える可能性を求めるべきではない。
役立つケースは下記
- インタフェースが別のインタフェースを実装していないかどうかをチェックする場合
- APIを作成している場合
	- 不特定多数が利用するライブラリや、構造が動的なデータを扱う場合は、型スイッチが不可欠になります。
- エラーハンドリング
	- 大規模プロダクトにおいて、型スイッチが最も活躍するのは **「独自の型を持つエラーの判定」** です。 Go 1.13以降は `errors.As` が推奨されますが、その内部では型アサーションが使われています。
	- ```go
	  if err != nil {
	    var queryErr *MyQueryError
	    if errors.As(err, &queryErr) {
	        // 特定のDBエラーの場合の専用処理
	        fmt.Println(queryErr.SQL)
	    }
	}
	  ```


#### ==関数型とインタフェース==
- **使い分け**
その一つの関数が、他の多くの関数や引数に、指定されていない他の状態変数に依存する場合は、インタフェースを引数として使い、関数をそのインタフェースに繋ぐための関数型を定義します。

##### 1. その引数に「状態（データ）」が必要か？
- **インターフェース:** その処理に付随するデータ（DB接続、設定値など）を、構造体のフィールドとして保持してほしい場合に適しています。
- **関数型:** その場限りの計算ロジックや、シンプルなフィルター処理など、**「入力に対して出力を出すだけ」**の純粋なロジックを求める場合に適しています。

##### 2. 将来的な拡張性
- **インターフェース:** 「今は `Run` だけだけど、将来的に `Stop` や `Pause` も必要になるかも」という場合は、インターフェースにしておくべきです。
- **関数型:** 「この引数は、**一生このシグネチャ（引数と戻り値の形）**でしか呼ばない」と断言できる場合に適しています。
##### 3. テストのしやすさ（Mock）
- **インターフェース:** モックツール（mockgenなど）で自動生成しやすく、大規模開発でのテストに向いています。
- **関数型:** テストコードの中で、その場でサッと関数を定義して渡せるため、小回りがききます。

#### ==暗黙のインタフェースによる依存性注入==
「コードはタスクを実行するために必要な機能を明示的に指定しなければならない」
Goは依存性の注入が容易

**「使う側がルール（設計図）を決め、作る側はそのルールを知らなくて良い」** という仕組みです。
- **一般的な言語:** 「私はこの設計図で作ります！」という宣言（`implements`）が必要。
- **Go言語:** 「必要な機能を持っていれば、誰でもOK！」という**後出しジャンケン**が可能。

```go
//例：メッセージを送信する機能

### ステップ1：【使う側】がインターフェースを決める
「送信できる(Send)機能さえあれば、何でもいいよ」と宣言します。

package consumer

// 使う側が「欲しい機能」を定義
type Sender interface {
    Send(message string)
}

// 誰かが送ってくれるのを待っている構造体
type NotificationService struct {
    sender Sender // ここに「具体的な何か」を注入(DI)する
}

func (s *NotificationService) Notify(msg string) {
    s.sender.Send(msg)
}

### ステップ2：【作る側】は自由に作る
**重要：** ここで「インターフェースを実装するぞ」と意識する必要はありません。

package provider

import "fmt"

type Email struct{}

// たまたま Send という名前のメソッドを持っているだけ
func (e Email) Send(msg string) {
    fmt.Println("メール送信:", msg)
}


### ステップ3：【メイン】でガッチャンコする（これがDI）
ここで初めて、両者が出会います。

func main() {
    // 1. 具体的な中身（Email）を作る
    myEmail := provider.Email{}

    // 2. 使う側（Service）に「注入」する
    // EmailはSendメソッドを持っているので、暗黙的にSenderとして認められる！
    service := consumer.NotificationService{sender: myEmail}

    service.Notify("こんにちは！")
}
```

##### なぜこれが「依存性注入（DI）」に役立つのか？

###### 1. 修正に強い（デカップリング）
もし「メール」ではなく「LINE」で送りたくなったら、新しい構造体を作るだけです。`consumer` パッケージ（使う側）のコードは**1文字も変える必要がありません。**

##### 2. テストが簡単
本物のメールを送る代わりに、テスト用の「偽物（Mock）」をその場で作って注入できます。

##### 3. 依存関係がスッキリする
「作る側」は「使う側」のことを知らなくていいため、パッケージ同士が複雑に絡み合う（循環参照）のを防げます。