---
up: "[[初めてのGo言語]]"
related:
tags:
  - golang
aliases:
  - golang
created: 2025-12-24
updated: 2025-12-24
---
### 概要

#### ==ジェネリクス==
型だけは違うが、ロジックは同じ関数やフィールドの型だけが違っていて、他は同じ構造体を類似のコードを繰り返さずに書ければ防いでくれる仕組み
ジェネリクス = 型パラメーター（引数）

- ジェネリクスが必要な理由
- Goのジェネリクスでできること、できないこと
- Goのジェネリクスの適切な利用方法

### 詳細

#### ==ジェネリクスのメリット -- 重複の削除と型安全性の向上==
型パラメータの特徴
- `[...]` で囲む
- `引数名：型名` 
- 任意の名前が使えるが、「T」を使うのが習慣になっています。
- ゼロ値：`var zero T` T型の変数宣言。この時点でzeroにはTのゼロ値が入る

```go
type stack[T any] struct {
	data []T
}

func (s *stack[T]) push(item T) {
	s.data = append(s.data, item)
}

func main() {
	s := stack[int]{}
	s.push(1)
	s.push(2)
	s.push(3)
	fmt.Println(s.data) // [1 2 3]
}
```

#### ==ジェネリクス関数==
「**処理（アルゴリズム）は同じだけど、扱う型だけが違う**」という場合に、特定の型に縛られずに使い回せる関数のことです。

```go
func Contains[T comparable](slice []T, target T) bool
```

| **パーツ**                | **名称**     | **役割**                                              |
| ---------------------- | ---------- | --------------------------------------------------- |
| **`func`**             | キーワード      | 関数の宣言を開始します。                                        |
| **`Contains`**         | 関数名        | この処理の名前です。                                          |
| **`[T ...]`**          | **型引数リスト** | この関数内で「仮の型」として使う `T` を宣言します。                        |
| **`comparable`**       | **型制約**    | `T` に入れる型は「比較演算子（==  や !=）」が使える型でなければならない、というルールです。 |
| **`(slice []T, ...)`** | 第1引数       | 型 `T` の要素を持つスライスを受け取ります。                            |
| **`(..., target T)`**  | 第2引数       | 検索したい要素を受け取ります。**型はスライスの要素と同じ `T` であることが保証されます。**   |
| **`bool`**             | 戻り値の型      | 見つかれば `true`、なければ `false` を返します。                    |

##### なぜ `any` ではなく `comparable` なのか？

ここが最大のポイントです。
もし `[T any]` と書いてしまうと、関数の中で `if v == target` という比較ができなくなります。

- **`any`**: 何でも受け入れるが、中身が「比較できるもの」かどうか不明なため、== を使うとコンパイルエラーになります。
- **`comparable`**: Goの組み込みインターフェースで、== が使える型（int, string, bool, ポインタ、すべてのフィールドが比較可能な構造体など）だけに制限します。
これによって、関数内部で安全に比較ロジックが書けるようになります。


#### ==ジェネリクス==
anyやcomparable以外にも任意のインタフェースを指定可能

##### なぜインターフェースを制約に使うのか？
`any` を使うと「何でもできる」反面、関数の中で「何もできない（メソッドが呼べない）」というジレンマに陥ります。
インターフェースを制約に使うことで、**「型は自由だが、この振る舞い（メソッド）だけは持っていてほしい」** というワガママな要求をコンパイラに伝えることができます。

```go
// String() メソッドを持つ型なら何でも受け入れる制約
type Descriptor interface {
    Describe() string
}

func PrintDescription[T Descriptor](val T) {
    // TはDescribe()を持っていることが保証されているので呼び出せる
    fmt.Println(val.Describe())
}
```

#### ==型ターム==
**型ターム**は、型セットを構築するための「最小単位（材料）」のことです。
インターフェースの中に記述される一つ一つの要素を指します。

「 `|` 」で区切って、具象型を列挙します。
```go
type Intger interface {
	int | int64 // "int" と "int64" がそれぞれ型ターム
}

// 2. ジェネリクス関数で利用
// T は int か int64 のどちらかであることが保証される
func Sum[T Integer](a, b T) T {
	return a + b
}

func main() {
	// int として使う
	fmt.Println(Sum(10, 20)) // 30

	// int64 として使う
	var x, y int64 = 100, 200
	fmt.Println(Sum(x, y)) // 300

	// ❌ string など、許可されていない型で呼ぶとコンパイルエラー
	// Sum("a", "b") // type string does not satisfy Integer
}
```

###### チルデ（~）
「近似記号（Approximation operator）」とも呼ばれる
一言でいうと、「**その型そのものだけでなく、その型をベースにして作った独自の型も全部OKにする**」という魔法の記号です。

Goでは `type MyInt int` のように、既存の型をベースに新しい型を作ることができます。`~` はこの「派生した型」を許容するかどうかを決めます。


###### 1. `~` がない場合（厳密一致）

```go
type Strict interface {
    int
}
// int型はOK。
// type MyInt int で作った MyInt型はNG（別物とみなされる）。
```

###### 2. `~` がある場合（下底型が一致すればOK）

```go
type Flexible interface {
    ~int
}
// int型はもちろんOK。
// MyInt型（ベースがint）もOKになる！
```

###### 3. なぜ `~` が必要なのか？（実用例）
大規模な開発では、単なる `int` ではなく、意味を持たせるために独自の型を定義することがよくあります。

```go
type UserID int   // ユーザーID専用の型
type ProductID int // 商品ID専用の型

// 「数値を2倍にする」という汎用的な関数を作りたい
func Double[T ~int](v T) T {
    return v * 2
}

func main() {
    var uid UserID = 10
    var pid ProductID = 20

    // ~int と定義しているので、UserID型もProductID型もそのまま渡せる！
    fmt.Println(Double(uid)) 
    fmt.Println(Double(pid))
}
```

#### ==型推論とジェネリクス==
`:=` を使用する際に型推論が働く。
ジェネリクス関数の呼び出しを単純にするための型推論もしてくれます。

```go
func PrintValue[T any](v T) {
    fmt.Println(v)
}

func main() {
    // A. 明示的に型を指定する場合
    PrintValue[int](100)

    // B. 型推論を使う場合（省略）
    PrintValue(100) // コンパイラが引数の 100 を見て T = int と推論する
}
```

##### 型推論が「失敗」するケース（型指定が必要な時）
引数がないため、ヒントが足りず推論できません。

```go
func GetZero[T any]() T {
    var zero T
    return zero
}

func main() {
    // ❌ エラー：T が何か分からない
    // z := GetZero() 

    // ⭕️ OK：型を指定する
    z := GetZero[int]() 
}
```

#### イディオム的なGoとジェネリクス
ジェネリクスが誕生したことで、Goのベストプラクティスは変更される
- 任意の数値型を表現するために、float64を使う必然性がなくなる
- データ構造や関数の引数で任意の型を表すのに、interface{}の代わりに `any` を使うことになる
- 同じ関数で異なる型のスライスを扱うことができます