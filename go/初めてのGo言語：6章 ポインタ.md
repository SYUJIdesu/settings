---
up: "[[初めてのGo言語]]"
related:
tags:
  - golang
aliases:
  - golang
created: 2025-12-22
updated: 2025-12-22
---
### 概要

##### ==ポインタとは、ある値が保存されているメモリ内の位置を表す変数の住所（アドレス）のことである==

```go
var x int32 = 10
var y bool = true
```

##### ==メモリ内に変数を保存==

| 値        | 0   | 0   | 0   | 10  | 1   |
| -------- | --- | --- | --- | --- | --- |
| **アドレス** | 1   | 2   | 3   | 4   | 5   |
| **変数**   | x   |     |     |     | y   |

##### ==アドレス==
1バイトもしくは何バイトか連続したメモリに保存されており、その位置を「アドレス」と呼ぶ
変数の型が違えば、保存に必要なメモリの量も異なります
上記の例は32ビット = 4バイト
ポインタのサイズは型が違っても全部一緒。メモリ内のデータが保存されている位置（アドレス）を示す値だから

##### ==ポインタを使うべき4つのケース==

###### 1. 関数の中で「引数の中身」を書き換えたいとき
Goは「値渡し（コピー）」の言語です。ポインタを使わないと、関数の中での変更は呼び出し元に反映されません。
```go
func updateName(u *User) {
    u.Name = "New Name" // ポインタなので原本が書き換わる
}
```

###### 2. 巨大な構造体を渡すとき（パフォーマンス向上）
構造体のサイズが大きい（フィールドが多い）場合、関数に渡すたびに丸ごとコピーするとメモリとCPUを消費します。ポインタなら**一律8バイト（住所のみ）**の転送で済むため、高速です。

###### 3. 「値がない（nil）」を表現したいとき
通常の型（`int` や `string`）は空でも「ゼロ値（0や""）」が入っています。「未設定」なのか「0を設定した」のかを区別したい場合、ポインタを使います。
```go
type Profile struct {
    Age *int // nil なら「未回答」、0 なら「0歳」と区別できる
}
```

###### 4. メソッドレシーバの整合性を保つとき
構造体のメソッドを定義する際、「1つでもポインタレシーバがあるなら、他もすべてポインタレシーバにする」のがGoの鉄則（一貫性の保持）です。

```go
func (s *stack) push(v int) { ... } // 状態を変える
func (s *stack) length() int { ... } // 状態は変えないが、一貫性のために * にする
```

### 詳細

##### ==ポインタのゼロ値==
nilです。
スライス・マップ・関数のゼロ値で、これらの型は全てポインタで実装されています。
（インタフェースとチャネルも）

##### ==「&」はアドレス演算子==
変数の前につけるとその変数のアドレスを返す。
返された値は**ポインタ型**になります。
```go
x := 10
point := &x
fmt.Println(point) // 0x14000106020
```


##### ==「 `*` 」は間接参照==
ポインタの変数の前につけると、ポインタが参照するアドレスに保存されている値を返します。
これを **デリファレンス**と呼ぶ
- **意味:** 実体（中身）へのアクセス
- **イメージ:** 住所の場所にワープして、ロッカーを開ける行為
```go
x := 10
point := &x
fmt.Println(*point) // 10
z := 20 + *point
fmt.Println(z) // 30
```

###### new関数を使う
関数newはポインタ型の変数を生成するがほとんど使われない
```go
// int型の領域を確保し、そのポインタを p に入れる
// ※ p は nil ではなく、中身が 0 の場所を指している
p := new(int)
*p = 50 // 後から代入する
```

##### ==「 `*` 」を型として使う場合（ `*int`, `*string` ）==
変数を宣言するときに型名の前につく `*` は、「**これは住所を入れるための変数（ポインタ変数）ですよ**」という目印です。
- **意味:** ポインタ型の宣言
```go
x := 10
var point *int // p は「int型のデータが入っている住所」を入れる変数
println(point) // 0x0
point = &x
println(point)  // 0x1400004e730
println(*point) // 10

var s int
println(s) // 0

```

##### ==ポインタは最後の手段==
データの流れとガベージコレクタの仕事も増えます。
関数にポインタを渡して構造体の中身を埋めるのではなく、関数が構造体のインスタンスを生成して返すようにする

<mark style="background: #FF5582A6;">変数を変更するのにポインタ引数を使わなくてはならないのは関数がインターフェースを受け取る時だけです</mark>

```go

//悪い例
func makeFoo(f *foo) error {
	f.filed = "val"
	return nil
}

// いい例
func makeFoo() (Foo, error) {
	f := Foo{
		filed: "val"
	}
	return f, nil
}
```
