---
up: "[[初めてのGo言語]]"
related:
tags:
  - golang
aliases:
  - golang
created: 2025-12-20
updated: 2025-12-20
---
### 概要

##### ブロック

|**階層**|**名前**|**説明**|**具体例**|
|---|---|---|---|
|**1 (最上位)**|**ユニバースブロック**|言語全体で有効。|`int`, `true`, `error` など (前回解説した「事前宣言された型」)|
|**2**|**パッケージブロック**|**関数の外で宣言された変数、定数、型、関数**|トップレベルの `var`, `func`, `type`, `const`|
|**3**|**ファイルブロック**|そのファイル内でのみ有効。|**`import` されたパッケージ名** (`fmt` など)|
|**4 (最下位)**|**ローカルブロック**|関数や `if` 文の中でのみ有効。|関数内の `x := 10` など|]


### 詳細

#### ==変数のシャドーイング==
**「内側のブロック（スコープ）で定義した変数が、外側の同じ名前の変数を『隠して』しまう現象」** のことです。

Go言語では、特に `:=`（短縮宣言）を使うときに頻発し、**「変数が更新されていない！」というバグの温床**になりやすいため、非常に注意が必要

原因は **`:=`（定義と代入）** です。 Go言語の仕様では、`:=` を使うと、左側の変数が新しく宣言されます。
- `n = 20` と書けば、外側の `n` への**代入（更新）**になります。
- `n := 20` と書くと、そのブロック内専用の**新しい変数 `n` の作成**になります。

```go

n := 10 // ① 外側の n

if true {
	// ここで罠！ := を使ってしまった
	// これは「更新」ではなく「新しい変数 n の作成」になる
	n := 20 // ② 内側の n（①を隠す）
	fmt.Println("中:", n) // -> 中: 20
}
// ブロックを抜けたら、②の n は消滅し、隠れていた ① が復活する
fmt.Println("外:", n) // -> 外: 10 （あれ！？変わってない！）


// 解決策　

// 外側で変数宣言
var x int // 先に宣言
var err error

if true {
    x, err = doSomething() // := ではなく = を使う
}

// 変数名を変える（推奨）
if true {
    // n ではなく innerN にする
    innerN := 20
    fmt.Println(innerN)
}

// ツールで検知する
// Goの標準コマンド `go vet` や、エディタの設定で「シャドーイングを警告する」機能をONにしておくと、コンパイル前のような段階で教えてくれます。
```

#### ==if==
Go言語の **if文** は、C言語やJavaと似ていますが、**「シンプルさ」** と **「スコープ（変数の有効範囲）を制限する機能」** に特徴があります。

##### 1. 基本の書き方
最大の特徴は **「条件式の周りに `( )` 丸括弧を書かない」** ことです。 一方で、**`{ }` 波括弧は必須** です（1行だけの処理でも省略できません）
`if n == 0 {} else {}`
##### 2. 「簡易文付き」if文（Goの便利機能）
Goのif文では、条件判定の直前に **「短い文（変数の宣言など）」** を書くことができます。 これを **「簡易文 (Simple Statement)」** と呼びます。
`if 簡易文; 条件 { ... }`

変数のスコープは、ifとelse 両方のブロックで有効な宣言可能

```go

if n := rand.Intn(10); n == 0 {

}　else if n > 5 {

} else {

}
fmt.PrintIn(n) // こちらは未定義
```

#### ==for==
for以外のループはないが、4種類のループがある
1. for - range
2. 条件部分のみを指定するもの
3. 「初期設定」「条件」「再設定」の三つがある標準的なループ
4. 無限ループ

##### 標準的なループ
`for 初期化; 条件; 更新 { ... }`
```go
for i := 0; i < 5; i++ {
    fmt.Println(i)
}
// 出力: 0 1 2 3 4
```

##### 条件部分のみを指定するもの
「ある条件が満たされている間繰り返す」書き方です。 C言語やJavaの `while (condition)` と同じ動きをします。
```go
n := 1

// for 条件 { ... }
for n < 100 {
    n *= 2
}
fmt.Println(n) // 128
```

##### 無限ループ
条件を書かないと無限ループになります。 サーバーの待機処理などでよく使われます。
```go
for {
    fmt.Println("終わらない...")   
    // 抜けるときは break を使う
    if someCondition {
        break
    }
}
```

##### for - range
スライス、マップ、文字列などを走査する場合は、**`for range`** を使います。 これがGoで**最もよく使う形**です

###### スライスの場合
```go
s := []string{"a", "b", "c"}
for i, v := range s {
	// i: インデックス (0, 1, 2)
	// v: 値 ("A", "B", "C")
	fmt.Println(i, v)
}
```

###### マップの場合（キーと値）
```go
m := map[string]int{"apple": 100, "banana": 200}

for i, v := range m {
    fmt.Println(i, v)
}
```

<mark style="background: #D2B3FFA6;">`range` の注意点・テクニック</mark>
Goでは「変数を作ったら使わないとエラー」になるため、`range` の戻り値をどう受け取るかが重要です。

###### インデックス（キー）だけ欲しい場合:
```go
for i := range s { 
    // 値(v)を受け取らなければOK
}
```

###### **値だけ欲しい場合（重要！）:** インデックスを **`_`（アンダースコア）** で捨てます。
```go
for _, v := range s {
    // i の代わりに _ を置く
    fmt.Println(v)
}
```

###### breakとcontinue
- `break` ：ループを完全に抜ける
- `continue`：今回の処理をスキップして、次のループへ進む。


###### マップのイテレーション
「HashDos」攻撃と順番固定でコードを書く人が出るので以下のような際のために乱数のハッシュアルゴリズムを使用している
```go
m := map[string]int{
  "a": 1,
  "c": 3,
  "b": 2,
}

for i := 0; i < 3; i++ {
  fmt.Println("ループ", i)
  for k, v := range m {
    fmt.Println(k, v)
  }
}
// ループ 0
// a 1
// c 3
// b 2
// ループ 1
// a 1
// c 3
// b 2
// ループ 2
// a 1
// c 3
// b 2
```

###### for - rangaの値コピー
- **`for _, v := range` の `v` はコピーである。**
- **中身を変更したいなら:** `v` を使わず `list[i]` を使う。
- **巨大な構造体なら:** `v` を使うとコピーコストがかかるので、`list[i]` を使うかポインタを使う。

- 変更が反映されないケース
```go
type User struct {
    Name  string
    Point int
}

func main() {
    users := []User{
        {Name: "Taro", Point: 10},
        {Name: "Jiro", Point: 20},
    }

    // 罠: ここで v は「コピー」を受け取っている
    for _, v := range users {
        v.Point = 100 // コピーを変更しているだけ！
    }

    // 結果: 元のデータは変わっていない...
    fmt.Println(users) 
    // -> [{Taro 10} {Jiro 20}]
}
```
- 変更が反映されるケース
```go
// 正解: インデックスを使って原本を触る
for i := range users {
	users[i].Point = 100 
}

fmt.Println(users) 
// -> [{Taro 100} {Jiro 100}] （変更された！）
```

###### ラベル付きbreak
Go言語で二重ループ（ネストされたループ）を一気に抜けるには、**「ラベル付き break」** を使います。

通常の `break` と`continue` は一番内側のループしか抜けられませんが、ラベルを使うと指定したループの外側までジャンプできます。

ループの直前に「名前 + コロン(`:`)」でラベルを置き、`break ラベル名` と書きます。
```go
LoopEnd: 
    for i := 0; i < 3; i++ {
        for j := 0; j < 3; j++ {
            if i == 1 && j == 1 {
                fmt.Println("脱出します！")
                // ラベルを指定して break
                break LoopEnd
            }
            fmt.Println(i, j)
        }
    }
    fmt.Println("ループの外側に来ました")
```

#### ==swtich==
Go言語の **`switch` 文** は、他の言語（C/Java/JavaScriptなど）に比べて、**「安全」かつ「超強力」** に進化しています。

最大の特徴は **「`break` を書かなくても勝手に止まる」** ことです。 これだけでバグが激減します。

5つの重要ポイントを解説します。

##### breakは不要！
他の言語では `break` を書き忘れると次の `case` に突入（フォールスルー）してしまいますが、Goでは**自動的に `break` されます。**
```go
s := "apple"

switch s {
case "apple":
    fmt.Println("リンゴです")
    // ここで自動的に終了！次のcaseには行かない
case "banana":
    fmt.Println("バナナです")
default:
    fmt.Println("その他です")
}
```

##### ひとつのcaseに「複数の値」を書ける
カンマ区切りで条件をまとめられます。「OR条件」のように使えて便利です。
```go
day := "Sunday"

switch day {
case "Saturday", "Sunday": // 土曜 または 日曜
    fmt.Println("お休みです")
case "Monday":
    fmt.Println("仕事始めです")
default:
    fmt.Println("平日です")
}
```

##### ブランクswitch（最強のif-else代用）
`switch` の横に何も書かないと、`case` に条件式（true/falseになる式）を書くことができます。 
複雑な `if - else if - else` チェーンよりも圧倒的に読みやすくなります。

※ Goの現場では、条件が3つ以上重なる `if` 文は、この `switch` に書き換えるのが好まれます。
```go
score := 85

// switchの横は空欄！
// または 変数宣言
// switch score := 85 {
switch {
case score >= 90:
    fmt.Println("S評価")
case score >= 80:
    fmt.Println("A評価") // ここにヒットして終わる
case score >= 60:
    fmt.Println("B評価")
default:
    fmt.Println("追試")
}
```

##### あえて突き抜ける `fallthrough`
C言語のように「次のcaseも実行させたい」という稀なケースでは、**`fallthrough`** キーワードを明示的に書きます。

※ `fallthrough` は次の `case` の**条件を無視して**実行してしまうので、使用には注意が必要です。
```go
n := 1

switch n {
case 1:
    fmt.Println("1です")
    fallthrough // 強制的に次の case 2 へ進む！
case 2:
    fmt.Println("2でもあります（または通過しました）")
}
// 出力:
// 1です
// 2でもあります
```

##### 型スイッチ (Type Switch)
Go特有の機能です。**インターフェース (`interface{}`) に入っている値の「型」** によって分岐できます。

```go
var x interface{} = "hello"

// x.(type) という特別な構文を使う
switch v := x.(type) {
case int:
    fmt.Println("整数です:", v * 2) // vはint型として使える
case string:
    fmt.Println("文字列です:", v + " world") // vはstring型として使える
default:
    fmt.Println("知らない型です")
}
```


##### ifとswtichの使い分け

|**状況**|**推奨**|**理由**|
|---|---|---|
|**分岐が 2つ (Yes/No)**|**`if`**|シンプルだから。|
|**分岐が 3つ以上**|**`switch`**|`else if` を連打するより圧倒的に読みやすいから。|
|**変数の値による分岐**|**`switch`**|`case "A", "B":` のようにまとめられるから。|
|**エラーチェック**|**`if`**|`if err != nil` はGoのイディオム（定型文）だから。

#### ==goto==
しかし、現代のプログラミング（特にGo）において、`goto` は **「禁じ手」に近い存在** です。使う場面は極めて限定的で、多くのGoエンジニアは一度も書かずにキャリアを終えることさえあります。

##### 「変数の宣言を飛び越えてジャンプすることはできない」
```go
func main() {
    goto LABEL // ジャンプしようとする

    x := 10 // ここで変数を宣言している（初期化）

LABEL:
    // ここに来たとき x はどうなってる？
    // 未定義？ゴミデータ？ という曖昧さを防ぐためエラーになる
    fmt.Println(x) 
}
// コンパイルエラー: goto LABEL jumps over declaration of x
```

##### `goto` を使うかもしれない唯一の場面
Go言語には強力な **「ラベル付き break」** や **`defer`** があるため、C言語で `goto` が使われていた場面（多重ループ脱出やエラー処理）のほとんどは、より安全な方法で代替できます。

それでも `goto` が使われるとしたら、以下のケースくらいです。
###### ケース：複雑に絡み合った多重ループからの脱出

「ラベル付きbreak」でも書けますが、フローによっては `goto` の方が直感的な場合がごく稀にあります。
```go
func main() {
    for i := 0; i < 10; i++ {
        for j := 0; j < 10; j++ {
            if complexCondition(i, j) {
                // ここでエラー処理専用の場所へ飛びたい
                goto ErrorHandler
            }
        }
    }
    return // 正常終了

ErrorHandler: // エラー処理を一箇所にまとめる
    fmt.Println("エラーが発生しました。リソースを解放します。")
    // ...
}
```